<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tableau de bord TRS</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #e9eafc 0%, #f4f6fa 100%);
            margin: 0;
        }
        .container {
            max-width: 1400px;
            margin: 30px auto;
            background: white;
            border-radius: 18px;
            box-shadow: 0 10px 40px rgba(102,126,234,0.10), 0 2px 8px rgba(118,75,162,0.06);
            padding: 0 0 40px 0;
            overflow: hidden;
        }
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 40px 30px 30px 30px;
            border-radius: 18px 18px 0 0;
            box-shadow: 0 4px 24px rgba(102,126,234,0.10);
        }
        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 20px;
        }
        .header-text {
            flex: 1;
        }
        .header-actions {
            flex-shrink: 0;
        }
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            font-weight: 600;
            letter-spacing: 1px;
        }
        .header p {
            font-size: 1.15em;
            opacity: 0.96;
        }
        .tabs {
            display: flex;
            border-bottom: 2px solid #eee;
            background: #f8f9fa;
        }
        .tab {
            padding: 18px 32px;
            cursor: pointer;
            font-weight: 500;
            color: #555;
            border: none;
            background: none;
            outline: none;
            transition: background 0.2s, color 0.2s;
            font-size: 1.08em;
        }
        .tab.active {
            color: #667eea;
            border-bottom: 3px solid #667eea;
            background: #fff;
        }
        .filters-bar {
            display: flex;
            gap: 24px;
            padding: 22px 36px 12px 36px;
            background: #f8f9fa;
            border-bottom: 1px solid #eee;
            flex-wrap: wrap;
        }
        .filter-group {
            display: flex;
            flex-direction: column;
        }
        .filter-group label {
            font-weight: 600;
            margin-bottom: 6px;
            color: #333;
            font-size: 1em;
        }
        .filter-group select, .filter-group input {
            padding: 9px 14px;
            border: 2px solid #ddd;
            border-radius: 9px;
            font-size: 1em;
            min-width: 160px;
            background: #fff;
            transition: border-color 0.2s;
        }
        .filter-group select:focus, .filter-group input:focus {
            outline: none;
            border-color: #667eea;
        }
        .date-range {
            display: flex;
            gap: 8px;
        }
        .date-range input {
            padding: 9px 14px;
            border: 2px solid #ddd;
            border-radius: 9px;
            font-size: 1em;
            min-width: 140px;
            background: #fff;
            transition: border-color 0.2s;
        }
        .date-range input:focus {
            outline: none;
            border-color: #667eea;
        }
        .kpi-cards {
            display: flex;
            gap: 32px;
            margin: 36px 0 24px 0;
            flex-wrap: wrap;
            justify-content: space-between;
        }
        .kpi-card {
            background: linear-gradient(135deg, #f8f9fa 60%, #e9eafc 100%);
            border-radius: 16px;
            box-shadow: 0 2px 16px rgba(102,126,234,0.07);
            padding: 32px 34px 28px 34px;
            min-width: 220px;
            flex: 1;
            text-align: center;
            position: relative;
            overflow: hidden;
            transition: box-shadow 0.2s, transform 0.2s;
            margin-bottom: 10px;
            animation: fadeInUp 0.7s;
        }
        .kpi-card:hover {
            box-shadow: 0 8px 32px rgba(102,126,234,0.13);
            transform: translateY(-2px) scale(1.03);
        }
        .kpi-icon {
            font-size: 2.1em;
            margin-bottom: 8px;
            color: #667eea;
            display: block;
            opacity: 0.85;
        }
        .kpi-label {
            color: #888;
            font-size: 1.08em;
            margin-bottom: 8px;
            font-weight: 500;
        }
        .kpi-value {
            font-size: 2.2em;
            font-weight: bold;
            color: #764ba2;
            letter-spacing: 1px;
        }
        .charts-row {
            display: flex;
            gap: 32px;
            flex-wrap: wrap;
            margin: 36px 0 0 0;
        }
        .chart-container {
            background: #fff;
            border-radius: 16px;
            box-shadow: 0 2px 16px rgba(102,126,234,0.07);
            padding: 24px 18px 18px 18px;
            flex: 1;
            min-width: 340px;
            transition: box-shadow 0.2s;
            animation: fadeInUp 0.8s;
        }
        .chart-container:hover {
            box-shadow: 0 8px 32px rgba(102,126,234,0.13);
        }
        .section-title {
            font-size: 1.18em;
            font-weight: 600;
            color: #667eea;
            margin-bottom: 18px;
            letter-spacing: 0.5px;
        }
        .loading {
            text-align: center;
            color: #667eea;
            padding: 40px;
            font-size: 1.2em;
        }
        .no-data {
            text-align: center;
            color: #888;
            padding: 40px;
            font-size: 1.1em;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            background: #fff;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(102,126,234,0.07);
            margin-top: 10px;
        }
        th, td {
            padding: 12px 14px;
            border-bottom: 1px solid #f0f0f0;
            text-align: left;
        }
        th {
            background: linear-gradient(90deg, #e9eafc 60%, #f8f9fa 100%);
            color: #667eea;
            font-weight: 600;
            font-size: 1.05em;
            position: sticky;
            top: 0;
            z-index: 2;
        }
        tr:hover {
            background: #f4f6fa;
        }
        tr:nth-child(even) {
            background: #fafaff;
        }
        .tab-content {
            display: none;
            padding: 30px;
        }
        .tab-content.active {
            display: block;
        }
        .export-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            margin: 10px 0;
            transition: transform 0.2s;
        }
        .export-btn:hover {
            transform: translateY(-2px);
        }
        .error-message {
            background: #fee;
            color: #c33;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            border-left: 4px solid #c33;
        }
        .info-message {
            background: #e3f2fd;
            color: #1976d2;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            border-left: 4px solid #1976d2;
        }
        .success-message {
            background: #efe;
            color: #363;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            border-left: 4px solid #363;
        }
        .refresh-btn {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
            border: none;
            padding: 9px 20px;
            border-radius: 9px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s;
            font-size: 1em;
        }
        .refresh-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(40,167,69,0.3);
        }
        .refresh-btn:active {
            transform: translateY(0);
        }
        .refresh-btn.loading {
            background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
            cursor: not-allowed;
        }

        .alert-low-chargeability {
            background-color: #fff3cd !important;
            border-left: 4px solid #ffc107;
        }

        .alert-low-chargeability:hover {
            background-color: #ffeaa7 !important;
        }

        .alert-low-rentability {
            background-color: #ffebee !important;
            border-left: 4px solid #f44336;
            color: #c62828 !important;
        }

        .alert-low-rentability:hover {
            background-color: #ffcdd2 !important;
        }

        .alert-excellent-performance {
            background-color: #e8f5e8 !important;
            color: #2e7d32 !important;
        }
        
        .alert-good-performance {
            background-color: #f1f8e9 !important;
            color: #558b2f !important;
        }
        
        .alert-medium-performance {
            background-color: #fff3e0 !important;
            color: #ef6c00 !important;
        }
        
        .alert-low-performance {
            background-color: #ffebee !important;
            color: #c62828 !important;
        }
        @keyframes fadeInUp {
            from { opacity: 0; transform: translateY(30px); }
            to { opacity: 1; transform: translateY(0); }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="header-content">
                <div class="header-text">
                    <h1>Tableau de bord TRS</h1>
                    <p>Visualisez et analysez la r√©partition du temps de vos √©quipes par P√¥le, Collaborateur et Mission.</p>
                </div>
                <div class="header-actions">
                    <button id="refreshBtn" class="refresh-btn">
                        üîÑ Mise √† jour
                    </button>
                </div>
            </div>
        </div>
        
        <div class="tabs">
            <button class="tab active" data-tab="dashboard">Dashboard</button>
            <button class="tab" data-tab="missions">Missions</button>
            <button class="tab" data-tab="facturation">Facturation</button>
            <button class="tab" data-tab="rentabilite">Rentabilit√©</button>
            <button class="tab" data-tab="performance">Performance</button>
            <button class="tab" data-tab="opportunites">Opportunit√©s</button>
        </div>

        <div class="filters-bar">
            <div class="filter-group">
                <label for="yearFilter">Ann√©e</label>
                <select id="yearFilter">
                    <option value="">Toutes les ann√©es</option>
                </select>
            </div>
            <div class="filter-group">
                <label for="monthFilter">Mois</label>
                <select id="monthFilter">
                    <option value="">Tous les mois</option>
                </select>
            </div>
            <div class="filter-group">
                <label for="startDate">P√©riode personnalis√©e</label>
                <div class="date-range">
                    <input type="date" id="startDate" placeholder="Date d√©but">
                    <input type="date" id="endDate" placeholder="Date fin">
                </div>
            </div>
            <div class="filter-group">
                <label for="buFilter">P√¥le</label>
                <select id="buFilter">
                    <option value="">Tous les p√¥les</option>
                </select>
            </div>
            <div class="filter-group">
                <label for="collabFilter">Collaborateur</label>
                <select id="collabFilter">
                    <option value="">Tous les collaborateurs</option>
                </select>
            </div>
            <div class="filter-group">
                <label for="missionFilter">Mission</label>
                <select id="missionFilter">
                    <option value="">Toutes les missions</option>
                </select>
            </div>
            <div class="filter-group">
                <label for="typeHeureFilter">Type d'heure</label>
                <select id="typeHeureFilter">
                    <option value="">Tous les types</option>
                </select>
            </div>
        </div>

        <!-- Dashboard Tab -->
        <div id="tab-dashboard" class="tab-content active">
            <div class="loading">Chargement des donn√©es...</div>
        </div>

        <!-- Missions Tab -->
        <div id="tab-missions" class="tab-content">
            <div class="loading">Chargement des missions...</div>
        </div>

        <!-- Facturation Tab -->
        <div id="tab-facturation" class="tab-content">
            <div class="loading">Chargement de la facturation...</div>
        </div>

        <!-- Rentabilit√© Tab -->
        <div id="tab-rentabilite" class="tab-content">
            <div class="loading">Chargement de la rentabilit√©...</div>
        </div>

        <!-- Performance Tab -->
        <div id="tab-performance" class="tab-content">
            <div class="loading">Chargement de la performance...</div>
        </div>

        <!-- Opportunit√©s Tab -->
        <div id="tab-opportunites" class="tab-content">
            <div class="loading">Chargement des opportunit√©s...</div>
        </div>
    </div>

    <script>
        // Variables globales
        let trsData = [];
        let missionsData = [];
        let facturesData = [];
        let tauxHorairesData = [];
        let initialesData = [];
        let opportunitesData = [];
        let filteredData = [];
        let charts = {};
        let currentTab = 'dashboard'; // Initialiser currentTab

        // Mappings
        let initialesToNom = {};
        let nomToInitiales = {};
        let gradeToTaux = {};

        // Parsing CSV robuste avec gestion des s√©parateurs et encodage
        function parseCSV(csvText) {
            let data = [];
            let lines = csvText.split('\n');
            if (lines.length < 2) return data;
            
            // D√©tecter le s√©parateur (; ou ,)
            let separator = ';';
            if (lines[0].includes(',')) separator = ',';
            
            let headers = lines[0].split(separator).map(h => h.replace(/"/g, '').trim());
            console.log('Headers d√©tect√©s:', headers);
            
            for (let i = 1; i < lines.length; i++) {
                if (lines[i].trim() === '') continue;
                
                let row = lines[i].split(separator);
                if (row.length === headers.length) {
                    let dataRow = {};
                    for (let j = 0; j < headers.length; j++) {
                        dataRow[headers[j]] = row[j] ? row[j].replace(/"/g, '').trim() : '';
                    }
                    data.push(dataRow);
                }
            }
            console.log('Donn√©es pars√©es:', data.length, 'lignes');
            return data;
        }

        // Chargement des donn√©es
        async function loadAllCSVs() {
            try {
                console.log('D√©but du chargement des CSV...');
                
                // Charger TRS
                console.log('Chargement TRS...');
                const trsResponse = await fetch('donn√©es_TRS.csv?v=' + Date.now());
                if (!trsResponse.ok) throw new Error('Fichier TRS non trouv√©');
                const trsText = await trsResponse.text();
                trsData = parseCSV(trsText);
                console.log('TRS charg√©:', trsData.length, 'lignes');
                console.log('Premi√®res lignes TRS:', trsData.slice(0, 3).map(row => ({ Nom: row['Nom'], Mois: row['Mois'] })));
                console.log('Toutes les Divisions uniques:', [...new Set(trsData.map(row => row['Division']))].filter(d => d));
                console.log('Premi√®res lignes TRS avec Division:', trsData.slice(0, 3).map(row => ({ Nom: row['Nom'], Division: row['Division'] })));

                // Charger Missions
                console.log('Chargement Missions...');
                const missionsResponse = await fetch('liste des missions.csv?v=' + Date.now());
                if (!missionsResponse.ok) throw new Error('Fichier missions non trouv√©');
                const missionsText = await missionsResponse.text();
                missionsData = parseCSV(missionsText);
                console.log('Missions charg√©es:', missionsData.length, 'lignes');

                // Charger Factures
                console.log('Chargement Factures...');
                const facturesResponse = await fetch('liste des factures.csv?v=' + Date.now());
                if (!facturesResponse.ok) throw new Error('Fichier factures non trouv√©');
                const facturesText = await facturesResponse.text();
                facturesData = parseCSV(facturesText);
                console.log('Factures charg√©es:', facturesData.length, 'lignes');

                // Charger Taux horaires
                console.log('Chargement Taux horaires...');
                const tauxResponse = await fetch('Taux horaire par grade.csv?v=' + Date.now());
                if (!tauxResponse.ok) throw new Error('Fichier taux horaires non trouv√©');
                const tauxText = await tauxResponse.text();
                tauxHorairesData = parseCSV(tauxText);
                console.log('Taux horaires charg√©s:', tauxHorairesData.length, 'lignes');

                // Charger Initiales
                console.log('Chargement Initiales...');
                const initialesResponse = await fetch('initiales.csv?v=' + Date.now());
                if (!initialesResponse.ok) throw new Error('Fichier initiales non trouv√©');
                const initialesText = await initialesResponse.text();
                initialesData = parseCSV(initialesText);
                console.log('Initiales charg√©es:', initialesData.length, 'lignes');

                // Charger Opportunit√©s
                console.log('Chargement Opportunit√©s...');
                const opportunitesResponse = await fetch('liste des opportunit√©s.csv?v=' + Date.now());
                if (!opportunitesResponse.ok) throw new Error('Fichier opportunit√©s non trouv√©');
                const opportunitesText = await opportunitesResponse.text();
                opportunitesData = parseCSV(opportunitesText);
                console.log('Opportunit√©s charg√©es:', opportunitesData.length, 'lignes');

                // Construire les mappings
                buildMappings();
                console.log('Mappings construits');
                
                // Initialiser l'onglet actif
                currentTab = 'dashboard';
                
                // Initialiser l'interface
                setupFilters();
                applyFilters();
                renderDashboard();
                console.log('Interface initialis√©e');

            } catch (error) {
                console.error('Erreur lors du chargement des donn√©es:', error);
                document.querySelectorAll('.loading').forEach(el => {
                    el.innerHTML = 'Erreur lors du chargement des donn√©es. V√©rifiez que tous les fichiers CSV sont pr√©sents.';
                });
            }
        }

        // Construction des mappings
        function buildMappings() {
            // Mapping initiales ‚Üî noms
            initialesData.forEach(row => {
                if (row['Nom'] && row['Initiales 1']) {
                    initialesToNom[row['Initiales 1']] = row['Nom'];
                    nomToInitiales[row['Nom']] = row['Initiales 1'];
                }
            });

            // Mapping grade ‚Üî taux horaire
            tauxHorairesData.forEach(row => {
                if (row['Grade'] && row['Taux horaire']) {
                    let taux = parseFloat(row['Taux horaire'].replace(/\s/g, ''));
                    if (!isNaN(taux)) {
                        gradeToTaux[row['Grade']] = taux;
                    }
                }
            });
        }

        // Fonction pour normaliser les dates (g√®re les formats DD/MM/YYYY et anciens formats fran√ßais)
        function normalizeDate(dateStr) {
            if (!dateStr) return '';
            
            // Si c'est d√©j√† au format DD/MM/YYYY, le convertir en YYYY-MM-DD
            let match = dateStr.match(/(\d{2})\/(\d{2})\/(\d{4})/);
            if (match) {
                let jour = match[1];
                let mois = match[2];
                let annee = match[3];
                return `${annee}-${mois}-${jour}`;
            }
            
            // Mapping des mois fran√ßais vers num√©ros (pour l'ancien format)
            const moisMapping = {
                'janv.': '01', 'janvier': '01',
                'f√©vr.': '02', 'f√©vrier': '02',
                'mars': '03',
                'avr.': '04', 'avril': '04',
                'mai': '05',
                'juin': '06',
                'juil.': '07', 'juillet': '07',
                'ao√ªt': '08',
                'sept.': '09', 'septembre': '09',
                'oct.': '10', 'octobre': '10',
                'nov.': '11', 'novembre': '11',
                'd√©c.': '12', 'd√©cembre': '12'
            };
            
            // Extraire le jour et le mois (ancien format)
            match = dateStr.match(/(\d{1,2})-([a-zA-Z√©√ª]+\.?)/);
            if (match) {
                let jour = match[1].padStart(2, '0');
                let moisFr = match[2].toLowerCase();
                let moisNum = moisMapping[moisFr];
                
                if (moisNum) {
                    // D√©tecter l'ann√©e bas√©e sur les donn√©es existantes
                    let annee = '2024';
                    
                    // Si on trouve un pattern avec ann√©e dans les donn√©es, on l'utilise
                    let anneeMatch = dateStr.match(/(\d{4})/);
                    if (anneeMatch) {
                        annee = anneeMatch[1];
                    }
                    
                    return `${annee}-${moisNum}-01`; // On retourne le 1er du mois pour grouper par mois
                }
            }
            
            return dateStr; // Retourner l'original si pas de match
        }

        // Fonction pour extraire l'ann√©e d'une date normalis√©e
        function extractYearFromDate(dateStr) {
            if (!dateStr) return '';
            
            // Si c'est au format YYYY-MM-DD
            let match = dateStr.match(/(\d{4})-\d{2}-\d{2}/);
            if (match) {
                return match[1];
            }
            
            // Si c'est au format DD/MM/YYYY
            match = dateStr.match(/(\d{2})\/(\d{2})\/(\d{4})/);
            if (match) {
                return match[3];
            }
            
            return '';
        }

        // Fonction pour extraire le mois d'une date normalis√©e
        function extractMonthFromDate(dateStr) {
            if (!dateStr) return '';
            
            // Si c'est au format YYYY-MM-DD
            let match = dateStr.match(/\d{4}-(\d{2})-\d{2}/);
            if (match) {
                return match[1];
            }
            
            // Si c'est au format DD/MM/YYYY
            match = dateStr.match(/(\d{2})\/(\d{2})\/(\d{4})/);
            if (match) {
                return match[2];
            }
            
            return '';
        }

        // Fonction pour convertir une date en objet Date
        function parseDate(dateStr) {
            if (!dateStr) return null;
            
            // Si c'est au format YYYY-MM-DD
            if (dateStr.match(/^\d{4}-\d{2}-\d{2}$/)) {
                return new Date(dateStr);
            }
            
            // Si c'est au format DD/MM/YYYY
            let match = dateStr.match(/(\d{2})\/(\d{2})\/(\d{4})/);
            if (match) {
                return new Date(match[3], match[2] - 1, match[1]);
            }
            
            return null;
        }

        // Fonction pour formater une date pour l'affichage
        function formatDateForDisplay(dateStr) {
            if (!dateStr) return '';
            
            const moisNoms = {
                '01': 'Janvier', '02': 'F√©vrier', '03': 'Mars', '04': 'Avril',
                '05': 'Mai', '06': 'Juin', '07': 'Juillet', '08': 'Ao√ªt',
                '09': 'Septembre', '10': 'Octobre', '11': 'Novembre', '12': 'D√©cembre'
            };
            
            // Si c'est d√©j√† au format YYYY-MM-DD
            let match = dateStr.match(/(\d{4})-(\d{2})-(\d{2})/);
            if (match) {
                let annee = match[1];
                let mois = match[2];
                let jour = match[3];
                return `${moisNoms[mois]} ${annee}`;
            }
            
            return dateStr; // Retourner l'original si pas de match
        }

        // Configuration des filtres
        function setupFilters() {
            console.log('Setup filters avec donn√©es:', trsData.length);
            console.log('currentTab lors du setup:', currentTab);
            console.log('Headers TRS disponibles:', Object.keys(trsData[0] || {}));
            console.log('Premi√®res lignes TRS avec Division:', trsData.slice(0, 3).map(row => ({ Nom: row['Nom'], Division: row['Division'] })));
            
            // V√©rifier que le DOM est pr√™t
            if (!document.getElementById('buFilter')) {
                console.error('DOM pas encore pr√™t, retry dans 100ms');
                setTimeout(setupFilters, 100);
                return;
            }
            
            // Collecter toutes les dates de tous les fichiers
            let allDates = [];
            
            // Dates TRS
            let trsDates = trsData.map(row => row['Mois']).filter(d => d);
            allDates = allDates.concat(trsDates);
            
            // Dates Factures
            if (facturesData && facturesData.length > 0) {
                let facturesDates = facturesData.map(row => row['Date']).filter(d => d);
                allDates = allDates.concat(facturesDates);
            }
            
            // Dates Opportunit√©s
            if (opportunitesData && opportunitesData.length > 0) {
                let opportunitesDates = opportunitesData.map(row => row['Date Insertion']).filter(d => d);
                allDates = allDates.concat(opportunitesDates);
                
                let derniereActionDates = opportunitesData.map(row => row['Date Derni√®re action']).filter(d => d);
                allDates = allDates.concat(derniereActionDates);
                
                let prochaineActionDates = opportunitesData.map(row => row['Date prochaine action']).filter(d => d);
                allDates = allDates.concat(prochaineActionDates);
            }
            
            console.log('Toutes les dates trouv√©es:', allDates);
            
            // Extraire directement les ann√©es et mois des dates DD/MM/YYYY
            let years = [];
            let months = [];
            
            allDates.forEach(dateStr => {
                // V√©rifier si c'est au format DD/MM/YYYY
                let match = dateStr.match(/(\d{2})\/(\d{2})\/(\d{4})/);
                if (match) {
                    let jour = match[1];
                    let mois = match[2];
                    let annee = match[3];
                    years.push(annee);
                    months.push(mois);
                } else {
                    // Fallback pour l'ancien format
                    let normalizedDate = normalizeDate(dateStr);
                    let year = extractYearFromDate(normalizedDate);
                    let month = extractMonthFromDate(normalizedDate);
                    if (year) years.push(year);
                    if (month) months.push(month);
                }
            });
            
            console.log('Dates analys√©es - DD/MM/YYYY trouv√©es:', allDates.filter(d => d.match(/(\d{2})\/(\d{2})\/(\d{4})/)).length);
            console.log('Dates analys√©es - ancien format trouv√©es:', allDates.filter(d => !d.match(/(\d{2})\/(\d{2})\/(\d{4})/)).length);
            
            // D√©dupliquer et trier
            years = [...new Set(years)].filter(y => y).sort();
            months = [...new Set(months)].filter(m => m).sort();
            
            console.log('Ann√©es trouv√©es:', years);
            console.log('Mois trouv√©s:', months);
            
            // Remplir les filtres
            fillSelect(document.getElementById('yearFilter'), years, 'Toutes les ann√©es');
            fillSelect(document.getElementById('monthFilter'), months, 'Tous les mois', (month) => {
                const moisNoms = {
                    '01': 'Janvier', '02': 'F√©vrier', '03': 'Mars', '04': 'Avril',
                    '05': 'Mai', '06': 'Juin', '07': 'Juillet', '08': 'Ao√ªt',
                    '09': 'Septembre', '10': 'Octobre', '11': 'Novembre', '12': 'D√©cembre'
                };
                return moisNoms[month] || month;
            });

            // Mettre √† jour les filtres selon l'onglet actif
            updateFiltersForCurrentTab();
        }

        // Fonction pour mettre √† jour les filtres selon l'onglet actif
        function updateFiltersForCurrentTab() {
            console.log('updateFiltersForCurrentTab - currentTab:', currentTab);
            console.log('updateFiltersForCurrentTab - trsData.length:', trsData.length);
            
            let bus = [];
            let collabs = [];
            let missions = [];
            
            // Pour tous les onglets, utiliser les donn√©es TRS comme base
            // car c'est le fichier principal avec les heures charg√©es
            bus = [...new Set(trsData.map(row => row['Division']))].filter(b => b);
            collabs = [...new Set(trsData.map(row => row['Nom']))].filter(c => c);
            missions = [...new Set(trsData.map(row => row['Missions']))].filter(m => m);
            let typesHeure = [...new Set(trsData.map(row => row['Type Heure']))].filter(t => t);
            
            console.log('P√¥les trouv√©s pour', currentTab, ':', bus);
            console.log('Collaborateurs trouv√©s pour', currentTab, ':', collabs.length);
            console.log('Missions trouv√©es pour', currentTab, ':', missions.length);
            console.log('Types d\'heure trouv√©s pour', currentTab, ':', typesHeure);
            console.log('Premi√®res lignes TRS pour debug:', trsData.slice(0, 2).map(row => ({ Nom: row['Nom'], Division: row['Division'], Missions: row['Missions'] })));
            
            console.log('Avant fillSelect - bus:', bus);
            let buFilterElement = document.getElementById('buFilter');
            console.log('Avant fillSelect - buFilter element:', buFilterElement);
            if (buFilterElement) {
                fillSelect(buFilterElement, bus, 'Tous les p√¥les');
            } else {
                console.error('√âl√©ment buFilter non trouv√© !');
            }
            fillSelect(document.getElementById('collabFilter'), collabs, 'Tous les collaborateurs');
            fillSelect(document.getElementById('missionFilter'), missions, 'Toutes les missions');
            fillSelect(document.getElementById('typeHeureFilter'), typesHeure, 'Tous les types');
        }

        function fillSelect(select, values, allLabel, formatter = null) {
            console.log('fillSelect - select:', select.id, 'values:', values, 'allLabel:', allLabel);
            select.innerHTML = `<option value="">${allLabel}</option>`;
            values.forEach(value => {
                let option = document.createElement('option');
                option.value = value;
                option.textContent = formatter ? formatter(value) : value;
                select.appendChild(option);
            });
            console.log('fillSelect - options ajout√©es:', select.options.length);
        }

        // Application des filtres
        function applyFilters() {
            console.log('Application des filtres pour l\'onglet:', currentTab);
            
            // Toujours utiliser les donn√©es TRS comme base
            // car c'est le fichier principal avec les heures charg√©es
            let sourceData = trsData;
            let dateField = 'Mois';
            
            if (!sourceData || sourceData.length === 0) {
                console.error('Aucune donn√©e disponible pour l\'onglet:', currentTab);
                filteredData = [];
                renderCurrentTab();
                return;
            }
            
            console.log('Filtrage de', sourceData.length, 'lignes pour', currentTab);
            
            filteredData = sourceData.filter(row => {
                let yearFilter = document.getElementById('yearFilter').value;
                let monthFilter = document.getElementById('monthFilter').value;
                let startDate = document.getElementById('startDate').value;
                let endDate = document.getElementById('endDate').value;
                let buFilter = document.getElementById('buFilter').value;
                let collabFilter = document.getElementById('collabFilter').value;
                let missionFilter = document.getElementById('missionFilter').value;
                let typeHeureFilter = document.getElementById('typeHeureFilter').value;
                
                console.log('Filtrage ligne - yearFilter:', yearFilter, 'monthFilter:', monthFilter, 'dateField:', dateField);

                // Filtre par ann√©e
                if (yearFilter && dateField && dateField !== '') {
                    let rowDate = row[dateField];
                    let rowYear = '';
                    
                    console.log('Ligne date:', rowDate, 'dateField:', dateField);
                    
                    if (rowDate) {
                        // V√©rifier si c'est au format DD/MM/YYYY
                        let match = rowDate.match(/(\d{2})\/(\d{2})\/(\d{4})/);
                        if (match) {
                            rowYear = match[3];
                            console.log('Date DD/MM/YYYY d√©tect√©e, ann√©e:', rowYear);
                        } else {
                            // Fallback pour l'ancien format
                            let normalizedRowDate = normalizeDate(rowDate);
                            rowYear = extractYearFromDate(normalizedRowDate);
                            console.log('Date ancien format, ann√©e extraite:', rowYear);
                        }
                        
                        if (rowYear !== yearFilter) {
                            console.log('Filtr√© par ann√©e:', rowYear, '!==', yearFilter);
                            return false;
                        }
                    } else {
                        console.log('Pas de date pour la ligne:', row);
                        return false; // Pas de date
                    }
                }
                
                // Filtre par mois
                if (monthFilter && dateField && dateField !== '') {
                    let rowDate = row[dateField];
                    let rowMonth = '';
                    
                    if (rowDate) {
                        // V√©rifier si c'est au format DD/MM/YYYY
                        let match = rowDate.match(/(\d{2})\/(\d{2})\/(\d{4})/);
                        if (match) {
                            rowMonth = match[2];
                        } else {
                            // Fallback pour l'ancien format
                            let normalizedRowDate = normalizeDate(rowDate);
                            rowMonth = extractMonthFromDate(normalizedRowDate);
                        }
                        
                        if (rowMonth !== monthFilter) {
                            console.log('Filtr√© par mois:', rowMonth, '!==', monthFilter);
                            return false;
                        }
                    } else {
                        return false; // Pas de date
                    }
                }
                
                // Filtre par p√©riode personnalis√©e
                if ((startDate || endDate) && dateField && dateField !== '') {
                    let rowDate = row[dateField];
                    if (rowDate) {
                        let normalizedRowDate = normalizeDate(rowDate);
                        let parsedRowDate = parseDate(normalizedRowDate);
                        
                        if (parsedRowDate) {
                            if (startDate) {
                                let start = new Date(startDate);
                                if (parsedRowDate < start) return false;
                            }
                            
                            if (endDate) {
                                let end = new Date(endDate);
                                if (parsedRowDate > end) return false;
                            }
                        }
                    } else {
                        return false; // Pas de date
                    }
                }
                
                // Filtres sp√©cifiques - toujours utiliser les colonnes TRS
                if (buFilter && row['Division'] !== buFilter) {
                    console.log('Filtr√© par p√¥le:', row['Division'], '!==', buFilter);
                    return false;
                }
                if (collabFilter && row['Nom'] !== collabFilter) {
                    console.log('Filtr√© par collaborateur:', row['Nom'], '!==', collabFilter);
                    return false;
                }
                if (missionFilter && row['Missions'] !== missionFilter) {
                    console.log('Filtr√© par mission:', row['Missions'], '!==', missionFilter);
                    return false;
                }
                if (typeHeureFilter && row['Type Heure'] !== typeHeureFilter) {
                    console.log('Filtr√© par type d\'heure:', row['Type Heure'], '!==', typeHeureFilter);
                    return false;
                }

                return true;
            });

            console.log('Donn√©es filtr√©es:', filteredData.length, 'pour l\'onglet:', currentTab);
            renderCurrentTab();
        }

        // Fonction pour rendre l'onglet actif
        function renderCurrentTab() {
            console.log('renderCurrentTab - currentTab:', currentTab);
            console.log('renderCurrentTab - filteredData.length:', filteredData.length);
            
            switch (currentTab) {
                case 'dashboard':
                    renderDashboard();
                    break;
                case 'missions':
                    renderMissionsTab();
                    break;
                case 'facturation':
                    renderFacturationTab();
                    break;
                case 'rentabilite':
                    renderRentabiliteTab();
                    break;
                case 'performance':
                    renderPerformanceTab();
                    break;
                case 'opportunites':
                    renderOpportunitesTab();
                    break;
                default:
                    renderDashboard();
            }
        }

        // Rendu du dashboard principal
        function renderDashboard() {
            console.log('renderDashboard - filteredData.length:', filteredData.length);
            console.log('renderDashboard - currentTab:', currentTab);
            console.log('renderDashboard - filteredData sample:', filteredData.slice(0, 3));
            
            if (!filteredData.length) {
                document.getElementById('tab-dashboard').innerHTML = '<div class="no-data">Aucune donn√©e √† afficher</div>';
                return;
            }

            // Calcul des KPIs
            let totalHeures = filteredData.reduce((sum, row) => sum + (parseFloat(row['Heures']) || 0), 0);
            let totalCollaborateurs = new Set(filteredData.map(row => row['Nom'])).size;
            let totalMissions = new Set(filteredData.map(row => row['Missions'])).size;
            let totalPoles = new Set(filteredData.map(row => row['Division'])).size;

            // HTML des KPIs
            let kpisHTML = `
                <div class="kpi-cards">
                    <div class="kpi-card">
                        <span class="kpi-icon">‚è∞</span>
                        <div class="kpi-label">Total Heures</div>
                        <div class="kpi-value">${totalHeures.toFixed(1)}h</div>
                    </div>
                    <div class="kpi-card">
                        <span class="kpi-icon">üë•</span>
                        <div class="kpi-label">Collaborateurs</div>
                        <div class="kpi-value">${totalCollaborateurs}</div>
                    </div>
                    <div class="kpi-card">
                        <span class="kpi-icon">üìã</span>
                        <div class="kpi-label">Missions</div>
                        <div class="kpi-value">${totalMissions}</div>
                    </div>
                    <div class="kpi-card">
                        <span class="kpi-icon">üè¢</span>
                        <div class="kpi-label">P√¥les</div>
                        <div class="kpi-value">${totalPoles}</div>
                    </div>
                </div>
            `;

            // Graphiques
            let chartsHTML = `
                <div class="charts-row">
                    <div class="chart-container">
                        <div class="section-title">R√©partition par P√¥le</div>
                        <canvas id="chartByBU"></canvas>
                    </div>
                    <div class="chart-container">
                        <div class="section-title">Top Collaborateurs</div>
                        <canvas id="chartTopCollab"></canvas>
                    </div>
                </div>
            `;

            document.getElementById('tab-dashboard').innerHTML = kpisHTML + chartsHTML;

            // Rendu des graphiques
            renderChart('chartByBU', getHoursByField(filteredData, 'Division'), 'bar', 'P√¥le', 'Heures');
            renderChart('chartTopCollab', getTopN('Nom', 5), 'bar', 'Collaborateur', 'Heures');
        }

        // Fonctions utilitaires pour les graphiques
        function getHoursByField(data, field) {
            let map = {};
            data.forEach(row => {
                let value = row[field];
                if (value) {
                    map[value] = (map[value] || 0) + (parseFloat(row['Heures']) || 0);
                }
            });
            return map;
        }

        function getTopN(field, n) {
            let map = getHoursByField(filteredData, field);
            return Object.entries(map)
                .sort((a, b) => b[1] - a[1])
                .slice(0, n)
                .reduce((obj, [key, value]) => {
                    obj[key] = value;
                    return obj;
                }, {});
        }

        // Rendu des graphiques Chart.js
        function renderChart(canvasId, dataMap, type, label, valueLabel) {
            const ctx = document.getElementById(canvasId);
            if (!ctx) return;

            if (charts[canvasId]) {
                charts[canvasId].destroy();
            }

            charts[canvasId] = new Chart(ctx, {
                type: type,
                data: {
                    labels: Object.keys(dataMap),
                    datasets: [{
                        label: valueLabel,
                        data: Object.values(dataMap),
                        backgroundColor: type === 'doughnut' ? [
                            '#667eea', '#764ba2', '#f6d365', '#fda085', '#43cea2', 
                            '#185a9d', '#f7971e', '#ffd200', '#536976', '#292e49'
                        ] : '#667eea',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: { display: false }
                    },
                    scales: type !== 'doughnut' ? {
                        x: { title: { display: true, text: label } },
                        y: { title: { display: true, text: valueLabel }, beginAtZero: true }
                    } : {}
                }
            });
        }

        // Gestion des onglets
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                // Retirer la classe active de tous les onglets
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                
                // Ajouter la classe active √† l'onglet cliqu√©
                tab.classList.add('active');
                const tabId = 'tab-' + tab.dataset.tab;
                document.getElementById(tabId).classList.add('active');
                
                // Mettre √† jour l'onglet actif
                currentTab = tab.dataset.tab;
                
                // Mettre √† jour les filtres pour le nouvel onglet
                updateFiltersForCurrentTab();
                
                // Appliquer les filtres pour l'onglet actif
                applyFilters();
            });
        });

        // Gestion des filtres
        document.querySelectorAll('select').forEach(select => {
            select.addEventListener('change', applyFilters);
        });
        
        // Gestion sp√©cifique du filtre type d'heure
        document.getElementById('typeHeureFilter').addEventListener('change', applyFilters);
        
        // Gestion des filtres de dates
        document.getElementById('startDate').addEventListener('change', applyFilters);
        document.getElementById('endDate').addEventListener('change', applyFilters);

        // Gestion du bouton de mise √† jour
        document.getElementById('refreshBtn').addEventListener('click', refreshData);

        // ===== ONGLET MISSIONS =====
        // Focus : Heures charg√©es et co√ªts internes
        function renderMissionsTab() {
            if (!filteredData.length) {
                document.getElementById('tab-missions').innerHTML = '<div class="no-data">Aucune donn√©e de missions disponible</div>';
                return;
            }

            let missionStats = calculateMissionStats();
            let totalHeures = filteredData.reduce((sum, row) => sum + (parseFloat(row['Heures']) || 0), 0);
            let totalCout = calculateTotalCost();

            let missionsHTML = `
                <div class="kpi-cards">
                    <div class="kpi-card">
                        <span class="kpi-icon">üìã</span>
                        <div class="kpi-label">Missions Actives</div>
                        <div class="kpi-value">${Object.keys(missionStats).length}</div>
                    </div>
                    <div class="kpi-card">
                        <span class="kpi-icon">‚è∞</span>
                        <div class="kpi-label">Total Heures</div>
                        <div class="kpi-value">${totalHeures.toFixed(1)}h</div>
                    </div>
                    <div class="kpi-card">
                        <span class="kpi-icon">üí∞</span>
                        <div class="kpi-label">Co√ªt Total</div>
                        <div class="kpi-value">${totalCout.toLocaleString()} XAF</div>
                    </div>
                    <div class="kpi-card">
                        <span class="kpi-icon">üë•</span>
                        <div class="kpi-label">Collaborateurs</div>
                        <div class="kpi-value">${new Set(filteredData.map(row => row['Nom'])).size}</div>
                    </div>
                    <div class="kpi-card">
                        <span class="kpi-icon">üìä</span>
                        <div class="kpi-label">Heures Moyennes/Mission</div>
                        <div class="kpi-value">${Object.keys(missionStats).length > 0 ? (totalHeures / Object.keys(missionStats).length).toFixed(1) : 0}h</div>
                    </div>
                    <div class="kpi-card">
                        <span class="kpi-icon">üèÜ</span>
                        <div class="kpi-label">Top Mission Co√ªteuse</div>
                        <div class="kpi-value">${getTopCostlyMission(missionStats)}</div>
                    </div>
                </div>
                <div class="charts-row">
                    <div class="chart-container">
                        <div class="section-title">Heures par Mission (Top 10)</div>
                        <canvas id="missionsChartHours"></canvas>
                    </div>
                    <div class="chart-container">
                        <div class="section-title">R√©partition par Type d'Heure</div>
                        <canvas id="missionsChartType"></canvas>
                    </div>
                </div>
                <div class="charts-row">
                    <div class="chart-container">
                        <div class="section-title">√âvolution des Heures par Mois</div>
                        <canvas id="missionsChartEvolution"></canvas>
                    </div>
                    <div class="chart-container">
                        <div class="section-title">R√©partition par Grade</div>
                        <canvas id="missionsChartGrade"></canvas>
                    </div>
                </div>
                <div class="charts-row">
                    <div class="chart-container">
                        <div class="section-title">Top Collaborateurs par Heures</div>
                        <canvas id="missionsChartCollaborateurs"></canvas>
                    </div>
                    <div class="chart-container">
                        <div class="section-title">Co√ªt par Division</div>
                        <canvas id="missionsChartDivision"></canvas>
                    </div>
                </div>
                <div class="chart-container" style="margin-top: 20px;">
                    <div class="section-title">D√©tail des Heures par Mission</div>
                    <table id="missionsTable">
                        <thead>
                            <tr>
                                <th>Mission</th>
                                <th>Division</th>
                                <th>Collaborateurs</th>
                                <th>Heures HC</th>
                                <th>Heures HNC</th>
                                <th>Total Heures</th>
                                <th>Co√ªt Total</th>
                                <th>Co√ªt Moyen/H</th>
                                <th>Taux Chargeabilit√©</th>
                                <th>Co√ªt/Collaborateur</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${generateMissionsTable()}
                        </tbody>
                    </table>
                </div>
            `;

            document.getElementById('tab-missions').innerHTML = missionsHTML;

            // Rendu des graphiques
            renderChart('missionsChartHours', getHoursByMission(), 'bar', 'Mission', 'Heures');
            renderChart('missionsChartType', getHoursByType(), 'doughnut', 'Type d\'heure', 'Heures');
            renderChart('missionsChartEvolution', getHoursByMonth(), 'line', 'Mois', 'Heures');
            renderChart('missionsChartGrade', getHoursByGrade(), 'bar', 'Grade', 'Heures');
            
            renderChart('missionsChartCollaborateurs', getTopCollaborateurs(), 'bar', 'Collaborateur', 'Heures');
            
            renderChart('missionsChartDivision', getCostByDivision(), 'bar', 'Division', 'Co√ªt (XAF)');
        }

        function calculateMissionStats() {
            let stats = {};
            filteredData.forEach(row => {
                let mission = row['Missions'];
                if (!mission) return;
                
                if (!stats[mission]) {
                    stats[mission] = {
                        division: row['Division'],
                        collaborateurs: new Set(),
                        heures: 0,
                        heuresHC: 0,
                        heuresHNC: 0,
                        cout: 0
                    };
                }
                
                stats[mission].collaborateurs.add(row['Nom']);
                let heures = parseFloat(row['Heures']) || 0;
                stats[mission].heures += heures;
                
                // Calculer le co√ªt bas√© sur le grade (uniquement pour les heures HC)
                if (row['Type Heure'] === 'HC') {
                    let grade = row['Grade'];
                    let tauxHoraire = gradeToTaux[grade] || 0;
                    stats[mission].cout += tauxHoraire * heures;
                    stats[mission].heuresHC += heures;
                } else {
                    stats[mission].heuresHNC += heures;
                }
            });
            
            return stats;
        }

        function calculateTotalCost() {
            return filteredData.reduce((sum, row) => {
                // Ne calculer le co√ªt que pour les heures HC (chargeables)
                if (row['Type Heure'] === 'HC') {
                    let grade = row['Grade'];
                    let tauxHoraire = gradeToTaux[grade] || 0;
                    let heures = parseFloat(row['Heures']) || 0;
                    return sum + (tauxHoraire * heures);
                }
                return sum;
            }, 0);
        }

        function getHoursByMission() {
            let map = {};
            filteredData.forEach(row => {
                let mission = row['Missions'];
                if (mission) {
                    map[mission] = (map[mission] || 0) + (parseFloat(row['Heures']) || 0);
                }
            });
            return Object.entries(map)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10)
                .reduce((obj, [key, value]) => {
                    obj[key] = value;
                    return obj;
                }, {});
        }

        function getCostByDivision() {
            let map = {};
            filteredData.forEach(row => {
                let division = row['Division'];
                if (division) {
                    // Ne calculer le co√ªt que pour les heures HC (chargeables)
                    if (row['Type Heure'] === 'HC') {
                        let grade = row['Grade'];
                        let tauxHoraire = gradeToTaux[grade] || 0;
                        let heures = parseFloat(row['Heures']) || 0;
                        map[division] = (map[division] || 0) + (tauxHoraire * heures);
                    }
                }
            });
            return map;
        }

        function getHoursByType() {
            let typeStats = {};
            filteredData.forEach(row => {
                let type = row['Type Heure'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                
                if (!typeStats[type]) {
                    typeStats[type] = 0;
                }
                typeStats[type] += heures;
            });
            
            return Object.entries(typeStats).map(([type, heures]) => ({
                label: type,
                value: heures
            }));
        }

        function getTopCostlyMission(missionStats) {
            let topMission = Object.entries(missionStats)
                .sort((a, b) => b[1].cout - a[1].cout)[0];
            return topMission ? topMission[0].substring(0, 20) + '...' : 'N/A';
        }

        function getHoursByMonth() {
            let monthStats = {};
            filteredData.forEach(row => {
                let mois = row['Mois'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                
                if (!monthStats[mois]) {
                    monthStats[mois] = 0;
                }
                monthStats[mois] += heures;
            });
            
            return monthStats;
        }

        function getHoursByGrade() {
            let gradeStats = {};
            filteredData.forEach(row => {
                let grade = row['Grade'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                
                if (!gradeStats[grade]) {
                    gradeStats[grade] = 0;
                }
                gradeStats[grade] += heures;
            });
            
            return gradeStats;
        }

        function getTopCollaborateurs() {
            let collaborateurStats = {};
            
            filteredData.forEach(row => {
                let nom = row['Nom'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                
                if (!collaborateurStats[nom]) {
                    collaborateurStats[nom] = 0;
                }
                collaborateurStats[nom] += heures;
            });
            
            // Retourner seulement le top 10 avec noms raccourcis
            return Object.entries(collaborateurStats)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10)
                .reduce((obj, [nom, heures]) => {
                    // Raccourcir le nom pour l'affichage
                    let nomCourt = nom.length > 15 ? nom.substring(0, 15) + '...' : nom;
                    obj[nomCourt] = heures;
                    return obj;
                }, {});
        }



        function generateMissionsTable() {
            let missionStats = calculateMissionStats();
            
            return Object.entries(missionStats)
                .sort((a, b) => b[1].heures - a[1].heures)
                .map(([mission, stats]) => {
                    let coutMoyen = stats.heures > 0 ? stats.cout / stats.heures : 0;
                    let heuresHC = stats.heuresHC || 0;
                    let heuresHNC = stats.heuresHNC || 0;
                    let tauxChargeabilite = stats.heures > 0 ? (heuresHC / stats.heures * 100) : 0;
                    let coutParCollaborateur = stats.collaborateurs.size > 0 ? stats.cout / stats.collaborateurs.size : 0;
                    
                    // Classe CSS pour les alertes de chargeabilit√©
                    let chargeabiliteClass = tauxChargeabilite < 70 ? 'alert-low-chargeability' : '';
                    
                    return `
                        <tr class="${chargeabiliteClass}">
                            <td>${mission}</td>
                            <td>${stats.division || ''}</td>
                            <td>${stats.collaborateurs.size}</td>
                            <td>${heuresHC.toFixed(1)}h</td>
                            <td>${heuresHNC.toFixed(1)}h</td>
                            <td>${stats.heures.toFixed(1)}h</td>
                            <td>${stats.cout.toLocaleString()} XAF</td>
                            <td>${coutMoyen.toFixed(0)} XAF/h</td>
                            <td>${tauxChargeabilite.toFixed(1)}%</td>
                            <td>${coutParCollaborateur.toLocaleString()} XAF</td>
                        </tr>
                    `;
                }).join('');
        }

        // ===== ONGLET FACTURATION =====
        // Focus : Facturation et encaissement
        function renderFacturationTab() {
            if (!facturesData.length) {
                document.getElementById('tab-facturation').innerHTML = '<div class="no-data">Aucune donn√©e de facturation disponible</div>';
                return;
            }

            let facturationStats = calculateFacturationStats();

            let facturationHTML = `
                <div class="kpi-cards">
                    <div class="kpi-card">
                        <span class="kpi-icon">üìÑ</span>
                        <div class="kpi-label">Total Factures</div>
                        <div class="kpi-value">${facturationStats.totalFactures}</div>
                    </div>
                    <div class="kpi-card">
                        <span class="kpi-icon">üí∞</span>
                        <div class="kpi-label">Montant Factur√©</div>
                        <div class="kpi-value">${facturationStats.montantFacture.toLocaleString()} XAF</div>
                    </div>
                    <div class="kpi-card">
                        <span class="kpi-icon">‚úÖ</span>
                        <div class="kpi-label">Montant Encaiss√©</div>
                        <div class="kpi-value">${facturationStats.montantEncaisse.toLocaleString()} XAF</div>
                    </div>
                    <div class="kpi-card">
                        <span class="kpi-icon">üìä</span>
                        <div class="kpi-label">Taux Encaissement</div>
                        <div class="kpi-value">${facturationStats.tauxEncaissement.toFixed(1)}%</div>
                    </div>
                </div>
                <div class="charts-row">
                    <div class="chart-container">
                        <div class="section-title">Facturation par Division</div>
                        <canvas id="facturationChartDivision"></canvas>
                    </div>
                    <div class="chart-container">
                        <div class="section-title">√âtat des Factures</div>
                        <canvas id="facturationChartEtat"></canvas>
                    </div>
                </div>
                <div class="chart-container" style="margin-top: 20px;">
                    <div class="section-title">D√©tail des Factures</div>
                    <table id="facturationTable">
                        <thead>
                            <tr>
                                <th>Client</th>
                                <th>Mission</th>
                                <th>Division</th>
                                <th>Montant Factur√©</th>
                                <th>Montant Encaiss√©</th>
                                <th>Solde</th>
                                <th>√âtat</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${generateFacturationTable()}
                        </tbody>
                    </table>
                </div>
            `;

            document.getElementById('tab-facturation').innerHTML = facturationHTML;

            // Rendu des graphiques
            renderChart('facturationChartDivision', getFacturationByDivision(), 'bar', 'Division', 'Montant (XAF)');
            renderChart('facturationChartEtat', getFacturationByEtat(), 'doughnut', '√âtat', 'Nombre');
        }

        function formatCurrency(value) {
            if (!value) return '0 XAF';
            let num = parseFloat(value.toString().replace(/\s/g, ''));
            return isNaN(num) ? '0 XAF' : num.toLocaleString() + ' XAF';
        }

        // ===== ONGLET RENTABILIT√â =====
        // Focus : Croisement TRS + Missions + Factures pour calculer la rentabilit√©
        function renderRentabiliteTab() {
            if (!filteredData.length) {
                document.getElementById('tab-rentabilite').innerHTML = '<div class="no-data">Aucune donn√©e disponible pour l\'analyse de rentabilit√©</div>';
                return;
            }

            let rentabiliteStats = calculateRentabiliteStats();

            let rentabiliteHTML = `
                <div class="kpi-cards">
                    <div class="kpi-card">
                        <span class="kpi-icon">üí∞</span>
                        <div class="kpi-label">CA Total</div>
                        <div class="kpi-value">${rentabiliteStats.caTotal.toLocaleString()} XAF</div>
                    </div>
                    <div class="kpi-card">
                        <span class="kpi-icon">üí∏</span>
                        <div class="kpi-label">Co√ªt Total</div>
                        <div class="kpi-value">${rentabiliteStats.coutTotal.toLocaleString()} XAF</div>
                    </div>
                    <div class="kpi-card">
                        <span class="kpi-icon">üìà</span>
                        <div class="kpi-label">Marge Brute</div>
                        <div class="kpi-value">${rentabiliteStats.margeBrute.toLocaleString()} XAF</div>
                    </div>
                    <div class="kpi-card">
                        <span class="kpi-icon">üìä</span>
                        <div class="kpi-label">Taux de Marge</div>
                        <div class="kpi-value">${rentabiliteStats.tauxMarge.toFixed(1)}%</div>
                    </div>
                    <div class="kpi-card">
                        <span class="kpi-icon">üéØ</span>
                        <div class="kpi-label">ROI Global</div>
                        <div class="kpi-value">${rentabiliteStats.roiGlobal.toFixed(1)}%</div>
                    </div>
                    <div class="kpi-card">
                        <span class="kpi-icon">üìã</span>
                        <div class="kpi-label">Taux Rentabilit√©</div>
                        <div class="kpi-value">${rentabiliteStats.tauxRentabilite.toFixed(1)}%</div>
                    </div>
                    <div class="kpi-card">
                        <span class="kpi-icon">üìà</span>
                        <div class="kpi-label">CA Moyen/Mission</div>
                        <div class="kpi-value">${rentabiliteStats.caMoyen.toLocaleString()} XAF</div>
                    </div>
                </div>
                <div class="charts-row">
                    <div class="chart-container">
                        <div class="section-title">Rentabilit√© par Mission</div>
                        <canvas id="rentabiliteChartMission"></canvas>
                    </div>
                    <div class="chart-container">
                        <div class="section-title">Rentabilit√© par Division</div>
                        <canvas id="rentabiliteChartDivision"></canvas>
                    </div>
                </div>
                <div class="charts-row">
                    <div class="chart-container">
                        <div class="section-title">√âvolution de la Rentabilit√© par Mois</div>
                        <canvas id="rentabiliteChartEvolution"></canvas>
                    </div>
                    <div class="chart-container">
                        <div class="section-title">R√©partition des Marges</div>
                        <canvas id="rentabiliteChartMarges"></canvas>
                    </div>
                </div>
                <div class="chart-container" style="margin-top: 20px;">
                    <div class="section-title">Analyse de Rentabilit√© par Mission</div>
                    <table id="rentabiliteTable">
                        <thead>
                            <tr>
                                <th>Mission</th>
                                <th>Division</th>
                                <th>Heures HC</th>
                                <th>Co√ªt Total</th>
                                <th>CA Factur√©</th>
                                <th>Marge</th>
                                <th>Taux Marge</th>
                                <th>ROI</th>
                                <th>Co√ªt/H HC</th>
                                <th>CA/H HC</th>
                                <th>Rentabilit√©</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${generateRentabiliteTable()}
                        </tbody>
                    </table>
                </div>
            `;

            document.getElementById('tab-rentabilite').innerHTML = rentabiliteHTML;

            // Rendu des graphiques
            renderChart('rentabiliteChartMission', getRentabiliteByMission(), 'bar', 'Mission', 'Marge (XAF)');
            renderChart('rentabiliteChartDivision', getRentabiliteByDivision(), 'bar', 'Division', 'Marge (XAF)');
            renderChart('rentabiliteChartEvolution', getRentabiliteByMonth(), 'line', 'Mois', 'Marge (XAF)');
            renderChart('rentabiliteChartMarges', getRentabiliteByMarges(), 'doughnut', 'Tranche de marge', 'Nombre de missions');
        }

        // ===== ONGLET PERFORMANCE =====
        // Focus : Analyse des collaborateurs et de leur productivit√©
        function renderPerformanceTab() {
            if (!filteredData.length) {
                document.getElementById('tab-performance').innerHTML = '<div class="no-data">Aucune donn√©e disponible pour l\'analyse de performance</div>';
                return;
            }

            let performanceStats = calculatePerformanceStats();

            let performanceHTML = `
                <div class="kpi-cards">
                    <div class="kpi-card">
                        <span class="kpi-icon">üë•</span>
                        <div class="kpi-label">Collaborateurs Actifs</div>
                        <div class="kpi-value">${performanceStats.totalCollaborateurs}</div>
                    </div>
                    <div class="kpi-card">
                        <span class="kpi-icon">‚è∞</span>
                        <div class="kpi-label">Heures Moyennes/Collab</div>
                        <div class="kpi-value">${performanceStats.heuresMoyennes.toFixed(1)}h</div>
                    </div>
                    <div class="kpi-card">
                        <span class="kpi-icon">üéØ</span>
                        <div class="kpi-label">Taux de Chargeabilit√©</div>
                        <div class="kpi-value">${performanceStats.tauxChargeabilite.toFixed(1)}%</div>
                    </div>
                    <div class="kpi-card">
                        <span class="kpi-icon">‚ö°</span>
                        <div class="kpi-label">Plus Efficace</div>
                        <div class="kpi-value">${performanceStats.plusEfficace}</div>
                    </div>
                </div>
                <div class="charts-row">
                    <div class="chart-container">
                        <div class="section-title">Top 5 Collaborateurs (Productivit√©)</div>
                        <canvas id="performanceChartTop"></canvas>
                    </div>
                    <div class="chart-container">
                        <div class="section-title">Performance par Division</div>
                        <canvas id="performanceChartDivision"></canvas>
                    </div>
                </div>
                <div class="charts-row">
                    <div class="chart-container">
                        <div class="section-title">R√©partition HC/HNC</div>
                        <canvas id="performanceChartRepartition"></canvas>
                    </div>
                    <div class="chart-container">
                        <div class="section-title">√âvolution Performance</div>
                        <canvas id="performanceChartEvolution"></canvas>
                    </div>
                </div>
                <div class="chart-container" style="margin-top: 20px;">
                    <div class="section-title">Analyse de Performance par Collaborateur</div>
                    <table id="performanceTable">
                        <thead>
                            <tr>
                                <th>Collaborateur</th>
                                <th>Grade</th>
                                <th>Division</th>
                                <th>Total Heures</th>
                                <th>Heures HC</th>
                                <th>Heures HNC</th>
                                <th>Taux Chargeabilit√©</th>
                                <th>Ratio HC/HNC</th>
                                <th>Productivit√©</th>
                                <th>Productivit√© Relative</th>
                                <th>Statut</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${generatePerformanceTable()}
                        </tbody>
                    </table>
                </div>
            `;

            document.getElementById('tab-performance').innerHTML = performanceHTML;

            // Rendu des graphiques
            renderChart('performanceChartTop', getTopCollaborateursProductivite(), 'bar', 'Collaborateur', 'Ratio HNC/HC');
            renderChart('performanceChartDivision', getPerformanceByDivision(), 'bar', 'Division', 'Taux chargeabilit√© (%)');
            renderChart('performanceChartRepartition', getRepartitionHCHNC(), 'doughnut', 'Type d\'heure', 'Heures');
            renderChart('performanceChartEvolution', getPerformanceByMonth(), 'line', 'Mois', 'Taux chargeabilit√© (%)');
        }

        // ===== FONCTIONS FACTURATION =====
        function calculateFacturationStats() {
            let totalFactures = facturesData.length;
            let montantFacture = facturesData.reduce((sum, facture) => {
                let montant = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                return sum + montant;
            }, 0);
            let montantEncaisse = facturesData.reduce((sum, facture) => {
                let montant = parseFloat(facture['Montant Encaiss√©']?.replace(/\s/g, '') || '0');
                return sum + montant;
            }, 0);
            let tauxEncaissement = montantFacture > 0 ? (montantEncaisse / montantFacture) * 100 : 0;

            return {
                totalFactures,
                montantFacture,
                montantEncaisse,
                tauxEncaissement
            };
        }

        function getFacturationByDivision() {
            let divisionStats = {};
            facturesData.forEach(facture => {
                let division = facture['Division'] || 'Non d√©fini';
                let montant = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                
                if (!divisionStats[division]) {
                    divisionStats[division] = 0;
                }
                divisionStats[division] += montant;
            });

            return Object.entries(divisionStats)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10)
                .map(([division, montant]) => ({
                    label: division,
                    value: montant
                }));
        }

        function getFacturationByEtat() {
            let etatStats = {};
            facturesData.forEach(facture => {
                let montantFacture = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                let montantEncaisse = parseFloat(facture['Montant Encaiss√©']?.replace(/\s/g, '') || '0');
                let solde = montantFacture - montantEncaisse;
                let etat = solde === 0 ? 'Pay√©' : solde > 0 ? 'En attente' : 'Surpay√©';
                
                if (!etatStats[etat]) {
                    etatStats[etat] = 0;
                }
                etatStats[etat]++;
            });

            return Object.entries(etatStats).map(([etat, count]) => ({
                label: etat,
                value: count
            }));
        }

        function generateFacturationTable() {
            return facturesData.map(facture => {
                let montantFacture = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                let montantEncaisse = parseFloat(facture['Montant Encaiss√©']?.replace(/\s/g, '') || '0');
                let solde = montantFacture - montantEncaisse;
                let etat = solde === 0 ? 'Pay√©' : solde > 0 ? 'En attente' : 'Surpay√©';
                
                return `
                    <tr>
                        <td>${facture['Client'] || ''}</td>
                        <td>${facture['Mission'] || ''}</td>
                        <td>${facture['Division'] || ''}</td>
                        <td>${montantFacture.toLocaleString()} XAF</td>
                        <td>${montantEncaisse.toLocaleString()} XAF</td>
                        <td>${solde.toLocaleString()} XAF</td>
                        <td>${etat}</td>
                    </tr>
                `;
            }).join('');
        }

        // ===== FONCTIONS RENTABILIT√â =====
        function calculateRentabiliteStats() {
            // Calculer les co√ªts √† partir des donn√©es TRS filtr√©es
            let coutTotal = calculateTotalCost();
            
            // Calculer le CA √† partir des factures
            let caTotal = facturesData.reduce((sum, facture) => {
                let montant = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                return sum + montant;
            }, 0);
            
            let margeBrute = caTotal - coutTotal;
            let tauxMarge = caTotal > 0 ? (margeBrute / caTotal) * 100 : 0;
            
            // Nouveaux KPIs
            let roiGlobal = coutTotal > 0 ? (margeBrute / coutTotal) * 100 : 0;
            
            // Calculer le taux de rentabilit√© (missions rentables / total missions)
            let missionStats = {};
            filteredData.forEach(row => {
                let mission = row['Missions'] || 'Non d√©fini';
                if (!missionStats[mission]) {
                    missionStats[mission] = { cout: 0, ca: 0 };
                }
                if (row['Type Heure'] === 'HC') {
                    let heures = parseFloat(row['Heures']) || 0;
                    let taux = gradeToTaux[row['Grade']] || 0;
                    missionStats[mission].cout += heures * taux;
                }
            });
            
            facturesData.forEach(facture => {
                let mission = facture['Mission'] || 'Non d√©fini';
                let montant = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                if (!missionStats[mission]) {
                    missionStats[mission] = { cout: 0, ca: 0 };
                }
                missionStats[mission].ca += montant;
            });
            
            let missionsRentables = Object.values(missionStats).filter(stats => (stats.ca - stats.cout) > 0).length;
            let totalMissions = Object.keys(missionStats).length;
            let tauxRentabilite = totalMissions > 0 ? (missionsRentables / totalMissions) * 100 : 0;
            
            // CA moyen par mission
            let missionsFacturees = facturesData.length;
            let caMoyen = missionsFacturees > 0 ? caTotal / missionsFacturees : 0;

            return {
                caTotal,
                coutTotal,
                margeBrute,
                tauxMarge,
                roiGlobal,
                tauxRentabilite,
                caMoyen
            };
        }

        function getRentabiliteByMission() {
            let missionStats = {};
            
            // Calculer les co√ªts par mission (uniquement heures HC)
            filteredData.forEach(row => {
                let mission = row['Missions'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                let taux = gradeToTaux[row['Grade']] || 0;
                
                if (!missionStats[mission]) {
                    missionStats[mission] = { cout: 0, ca: 0 };
                }
                
                // Ne calculer le co√ªt que pour les heures HC
                if (row['Type Heure'] === 'HC') {
                    let cout = heures * taux;
                    missionStats[mission].cout += cout;
                }
            });
            
            // Ajouter les CA par mission depuis les factures
            facturesData.forEach(facture => {
                let mission = facture['Mission'] || 'Non d√©fini';
                let montant = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                
                if (!missionStats[mission]) {
                    missionStats[mission] = { cout: 0, ca: 0 };
                }
                missionStats[mission].ca += montant;
            });

            return Object.entries(missionStats)
                .map(([mission, stats]) => ({
                    label: mission,
                    value: stats.ca - stats.cout
                }))
                .sort((a, b) => b.value - a.value)
                .slice(0, 10);
        }

        function getRentabiliteByDivision() {
            let divisionStats = {};
            
            // Calculer les co√ªts par division (uniquement heures HC)
            filteredData.forEach(row => {
                let division = row['Division'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                let taux = gradeToTaux[row['Grade']] || 0;
                
                if (!divisionStats[division]) {
                    divisionStats[division] = { cout: 0, ca: 0 };
                }
                
                // Ne calculer le co√ªt que pour les heures HC
                if (row['Type Heure'] === 'HC') {
                    let cout = heures * taux;
                    divisionStats[division].cout += cout;
                }
            });
            
            // Ajouter les CA par division depuis les factures
            facturesData.forEach(facture => {
                let division = facture['Division'] || 'Non d√©fini';
                let montant = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                
                if (!divisionStats[division]) {
                    divisionStats[division] = { cout: 0, ca: 0 };
                }
                divisionStats[division].ca += montant;
            });

            return Object.entries(divisionStats)
                .map(([division, stats]) => ({
                    label: division,
                    value: stats.ca - stats.cout
                }))
                .sort((a, b) => b.value - a.value);
        }

        function getRentabiliteByMonth() {
            let monthStats = {};
            
            // Calculer les marges par mois
            filteredData.forEach(row => {
                let mois = row['Mois'] || 'Non d√©fini';
                let mission = row['Missions'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                let taux = gradeToTaux[row['Grade']] || 0;
                
                if (!monthStats[mois]) {
                    monthStats[mois] = { cout: 0, ca: 0 };
                }
                
                if (row['Type Heure'] === 'HC') {
                    let cout = heures * taux;
                    monthStats[mois].cout += cout;
                }
            });
            
            // Ajouter les CA par mois depuis les factures
            facturesData.forEach(facture => {
                let date = facture['Date'] || '';
                let mois = date.split('/')[1] || 'Non d√©fini'; // Extraire le mois de la date
                let montant = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                
                if (!monthStats[mois]) {
                    monthStats[mois] = { cout: 0, ca: 0 };
                }
                monthStats[mois].ca += montant;
            });
            
            return Object.entries(monthStats)
                .sort((a, b) => a[0].localeCompare(b[0]))
                .reduce((obj, [mois, stats]) => {
                    obj[mois] = stats.ca - stats.cout;
                    return obj;
                }, {});
        }

        function getRentabiliteByMarges() {
            let missionStats = {};
            
            // Calculer les marges par mission
            filteredData.forEach(row => {
                let mission = row['Missions'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                let taux = gradeToTaux[row['Grade']] || 0;
                
                if (!missionStats[mission]) {
                    missionStats[mission] = { cout: 0, ca: 0 };
                }
                
                if (row['Type Heure'] === 'HC') {
                    let cout = heures * taux;
                    missionStats[mission].cout += cout;
                }
            });
            
            facturesData.forEach(facture => {
                let mission = facture['Mission'] || 'Non d√©fini';
                let montant = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                
                if (!missionStats[mission]) {
                    missionStats[mission] = { cout: 0, ca: 0 };
                }
                missionStats[mission].ca += montant;
            });
            
            // Cat√©goriser les marges
            let margeCategories = {
                'D√©ficitaire (< 0)': 0,
                'Faible (0-50k)': 0,
                'Moyenne (50k-200k)': 0,
                '√âlev√©e (200k-500k)': 0,
                'Tr√®s √©lev√©e (> 500k)': 0
            };
            
            Object.values(missionStats).forEach(stats => {
                let marge = stats.ca - stats.cout;
                if (marge < 0) {
                    margeCategories['D√©ficitaire (< 0)']++;
                } else if (marge < 50000) {
                    margeCategories['Faible (0-50k)']++;
                } else if (marge < 200000) {
                    margeCategories['Moyenne (50k-200k)']++;
                } else if (marge < 500000) {
                    margeCategories['√âlev√©e (200k-500k)']++;
                } else {
                    margeCategories['Tr√®s √©lev√©e (> 500k)']++;
                }
            });
            
            return margeCategories;
        }

        function generateRentabiliteTable() {
            let missionStats = {};
            
            // Calculer les co√ªts par mission (uniquement heures HC)
            filteredData.forEach(row => {
                let mission = row['Missions'] || 'Non d√©fini';
                let division = row['Division'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                let taux = gradeToTaux[row['Grade']] || 0;
                
                if (!missionStats[mission]) {
                    missionStats[mission] = { 
                        division: division,
                        cout: 0, 
                        ca: 0,
                        heuresHC: 0
                    };
                }
                
                // Ne calculer le co√ªt que pour les heures HC
                if (row['Type Heure'] === 'HC') {
                    let cout = heures * taux;
                    missionStats[mission].cout += cout;
                    missionStats[mission].heuresHC += heures;
                }
            });
            
            // Ajouter les CA par mission depuis les factures
            facturesData.forEach(facture => {
                let mission = facture['Mission'] || 'Non d√©fini';
                let montant = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                
                if (!missionStats[mission]) {
                    missionStats[mission] = { 
                        division: facture['Division'] || 'Non d√©fini',
                        cout: 0, 
                        ca: 0,
                        heuresHC: 0
                    };
                }
                missionStats[mission].ca += montant;
            });

            return Object.entries(missionStats)
                .map(([mission, stats]) => {
                    let marge = stats.ca - stats.cout;
                    let tauxMarge = stats.ca > 0 ? (marge / stats.ca) * 100 : 0;
                    let roi = stats.cout > 0 ? (marge / stats.cout) * 100 : 0;
                    let coutParHeure = stats.heuresHC > 0 ? stats.cout / stats.heuresHC : 0;
                    let caParHeure = stats.heuresHC > 0 ? stats.ca / stats.heuresHC : 0;
                    let rentabilite = marge > 0 ? 'Rentable' : marge < 0 ? 'D√©ficitaire' : '√âquilibr√©';
                    
                    // Classes CSS pour les alertes
                    let alertClass = '';
                    if (marge < 0 || roi < 20) {
                        alertClass = 'alert-low-rentability';
                    }
                    
                    return `
                        <tr class="${alertClass}">
                            <td>${mission}</td>
                            <td>${stats.division}</td>
                            <td>${stats.heuresHC.toFixed(1)}h</td>
                            <td>${stats.cout.toLocaleString()} XAF</td>
                            <td>${stats.ca.toLocaleString()} XAF</td>
                            <td>${marge.toLocaleString()} XAF</td>
                            <td>${tauxMarge.toFixed(1)}%</td>
                            <td>${roi.toFixed(1)}%</td>
                            <td>${coutParHeure.toFixed(0)} XAF/h</td>
                            <td>${caParHeure.toFixed(0)} XAF/h</td>
                            <td>${rentabilite}</td>
                        </tr>
                    `;
                })
                .sort((a, b) => {
                    // Trier par rentabilit√© d√©croissante
                    let margeA = parseFloat(a.match(/td>([^<]+) XAF<\/td>/)[1].replace(/\s/g, ''));
                    let margeB = parseFloat(b.match(/td>([^<]+) XAF<\/td>/)[1].replace(/\s/g, ''));
                    return margeB - margeA;
                })
                .join('');
        }

        // ===== FONCTIONS PERFORMANCE =====
        function calculatePerformanceStats() {
            let collaborateurStats = {};
            
            filteredData.forEach(row => {
                let nom = row['Nom'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                let grade = row['Grade'] || 'Non d√©fini';
                let division = row['Division'] || 'Non d√©fini';
                let taux = gradeToTaux[grade] || 0;
                
                if (!collaborateurStats[nom]) {
                    collaborateurStats[nom] = {
                        heures: 0,
                        heuresHC: 0,
                        heuresHNC: 0,
                        cout: 0,
                        grade: grade,
                        division: division
                    };
                }
                
                collaborateurStats[nom].heures += heures;
                
                // Ne calculer le co√ªt que pour les heures HC
                if (row['Type Heure'] === 'HC') {
                    let cout = heures * taux;
                    collaborateurStats[nom].cout += cout;
                    collaborateurStats[nom].heuresHC += heures;
                } else {
                    collaborateurStats[nom].heuresHNC += heures;
                }
            });

            let totalCollaborateurs = Object.keys(collaborateurStats).length;
            let totalHeures = Object.values(collaborateurStats).reduce((sum, stats) => sum + stats.heures, 0);
            let heuresMoyennes = totalCollaborateurs > 0 ? totalHeures / totalCollaborateurs : 0;
            
            // Calculer le taux de chargeabilit√© global
            let totalHeuresHC = Object.values(collaborateurStats).reduce((sum, stats) => sum + stats.heuresHC, 0);
            let totalHeuresHNC = Object.values(collaborateurStats).reduce((sum, stats) => sum + stats.heuresHNC, 0);
            let tauxChargeabilite = (totalHeuresHC + totalHeuresHNC) > 0 ? (totalHeuresHC / (totalHeuresHC + totalHeuresHNC)) * 100 : 0;
            
            // Trouver le collaborateur le plus efficace (ratio HNC/HC le plus faible)
            let plusEfficace = Object.entries(collaborateurStats)
                .filter(([nom, stats]) => stats.heuresHC > 0 && (stats.heuresHC + stats.heuresHNC) > 0) // Seulement ceux avec des heures HC et total > 0
                .sort((a, b) => {
                    let ratioA = a[1].heuresHNC / a[1].heuresHC;
                    let ratioB = b[1].heuresHNC / b[1].heuresHC;
                    return ratioA - ratioB; // Plus le ratio est faible, meilleur
                })[0];
            let plusEfficaceName = plusEfficace ? plusEfficace[0] : 'N/A';

            return {
                totalCollaborateurs,
                heuresMoyennes,
                tauxChargeabilite,
                plusEfficace: plusEfficaceName
            };
        }





        function generatePerformanceTable() {
            let collaborateurStats = {};
            
            filteredData.forEach(row => {
                let nom = row['Nom'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                let grade = row['Grade'] || 'Non d√©fini';
                let division = row['Division'] || 'Non d√©fini';
                
                if (!collaborateurStats[nom]) {
                    collaborateurStats[nom] = {
                        heures: 0,
                        heuresHC: 0,
                        heuresHNC: 0,
                        grade: grade,
                        division: division
                    };
                }
                
                collaborateurStats[nom].heures += heures;
                
                if (row['Type Heure'] === 'HC') {
                    collaborateurStats[nom].heuresHC += heures;
                } else {
                    collaborateurStats[nom].heuresHNC += heures;
                }
            });

            // Calculer la productivit√© moyenne pour la comparaison
            let productivites = Object.values(collaborateurStats)
                .filter(stats => stats.heuresHC > 0)
                .map(stats => stats.heuresHNC / stats.heuresHC);
            let productiviteMoyenne = productivites.length > 0 ? 
                productivites.reduce((sum, val) => sum + val, 0) / productivites.length : 0;

            return Object.entries(collaborateurStats)
                .map(([nom, stats]) => {
                    let tauxChargeabilite = (stats.heuresHC + stats.heuresHNC) > 0 ? 
                        (stats.heuresHC / (stats.heuresHC + stats.heuresHNC)) * 100 : 0;
                    let ratioHCHNC = stats.heuresHC > 0 ? stats.heuresHNC / stats.heuresHC : 0;
                    let productiviteRelative = productiviteMoyenne > 0 ? 
                        ((productiviteMoyenne - ratioHCHNC) / productiviteMoyenne) * 100 : 0;
                    
                    // D√©terminer le statut
                    let statut = '';
                    let alertClass = '';
                    if (ratioHCHNC > 1.5) {
                        statut = '‚ö†Ô∏è Sous-performant';
                        alertClass = 'alert-low-performance';
                    } else if (ratioHCHNC < 0.5) {
                        statut = '‚úÖ Excellent';
                        alertClass = 'alert-excellent-performance';
                    } else if (ratioHCHNC < 1) {
                        statut = 'üëç Bon';
                        alertClass = 'alert-good-performance';
                    } else {
                        statut = '‚ö†Ô∏è √Ä am√©liorer';
                        alertClass = 'alert-medium-performance';
                    }
                    
                    return `
                        <tr class="${alertClass}">
                            <td>${nom}</td>
                            <td>${stats.grade}</td>
                            <td>${stats.division}</td>
                            <td>${stats.heures.toFixed(1)}h</td>
                            <td>${stats.heuresHC.toFixed(1)}h</td>
                            <td>${stats.heuresHNC.toFixed(1)}h</td>
                            <td>${tauxChargeabilite.toFixed(1)}%</td>
                            <td>${ratioHCHNC.toFixed(2)}</td>
                            <td>${ratioHCHNC.toFixed(2)}</td>
                            <td>${productiviteRelative.toFixed(1)}%</td>
                            <td>${statut}</td>
                        </tr>
                    `;
                })
                .sort((a, b) => {
                    // Trier par ratio HNC/HC croissant (meilleur en premier)
                    let ratioA = parseFloat(a.match(/td>([^<]+)<\/td>/g)[7].replace(/<\/?td>/g, ''));
                    let ratioB = parseFloat(b.match(/td>([^<]+)<\/td>/g)[7].replace(/<\/?td>/g, ''));
                    return ratioA - ratioB;
                })
                .join('');
        }

        function getTopCollaborateursProductivite() {
            let collaborateurStats = {};
            
            filteredData.forEach(row => {
                let nom = row['Nom'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                
                if (!collaborateurStats[nom]) {
                    collaborateurStats[nom] = { heuresHC: 0, heuresHNC: 0 };
                }
                
                if (row['Type Heure'] === 'HC') {
                    collaborateurStats[nom].heuresHC += heures;
                } else {
                    collaborateurStats[nom].heuresHNC += heures;
                }
            });

            let result = Object.entries(collaborateurStats)
                .filter(([nom, stats]) => stats.heuresHC > 0 && (stats.heuresHC + stats.heuresHNC) > 0) // Seulement ceux avec des heures HC et total > 0
                .map(([nom, stats]) => {
                    let ratio = stats.heuresHNC / stats.heuresHC;
                    return {
                        label: nom.length > 15 ? nom.substring(0, 15) + '...' : nom,
                        value: ratio
                    };
                })
                .sort((a, b) => a.value - b.value) // Plus le ratio est faible, meilleur
                .slice(0, 5);
            
            // Convertir en format attendu par renderChart
            let chartData = {};
            result.forEach(item => {
                chartData[item.label] = item.value;
            });
            
            return chartData;
        }

        function getPerformanceByDivision() {
            let divisionStats = {};
            
            filteredData.forEach(row => {
                let division = row['Division'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                
                if (!divisionStats[division]) {
                    divisionStats[division] = { heuresHC: 0, heuresHNC: 0 };
                }
                
                if (row['Type Heure'] === 'HC') {
                    divisionStats[division].heuresHC += heures;
                } else {
                    divisionStats[division].heuresHNC += heures;
                }
            });

            let result = Object.entries(divisionStats)
                .filter(([division, stats]) => (stats.heuresHC + stats.heuresHNC) > 0) // Seulement les divisions avec des heures
                .map(([division, stats]) => {
                    let totalHeures = stats.heuresHC + stats.heuresHNC;
                    let tauxChargeabilite = (stats.heuresHC / totalHeures) * 100;
                    return {
                        label: division,
                        value: tauxChargeabilite
                    };
                })
                .sort((a, b) => b.value - a.value);
            
            // Convertir en format attendu par renderChart
            let chartData = {};
            result.forEach(item => {
                chartData[item.label] = item.value;
            });
            
            return chartData;
        }

        function getRepartitionHCHNC() {
            let totalHeuresHC = 0;
            let totalHeuresHNC = 0;
            
            filteredData.forEach(row => {
                let heures = parseFloat(row['Heures']) || 0;
                
                if (row['Type Heure'] === 'HC') {
                    totalHeuresHC += heures;
                } else {
                    totalHeuresHNC += heures;
                }
            });

            return {
                'Heures Chargeables': totalHeuresHC,
                'Heures Non-Chargeables': totalHeuresHNC
            };
        }

        function getPerformanceByMonth() {
            let monthStats = {};
            
            filteredData.forEach(row => {
                let mois = row['Mois'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                
                if (!monthStats[mois]) {
                    monthStats[mois] = { heuresHC: 0, heuresHNC: 0 };
                }
                
                if (row['Type Heure'] === 'HC') {
                    monthStats[mois].heuresHC += heures;
                } else {
                    monthStats[mois].heuresHNC += heures;
                }
            });

            return Object.entries(monthStats)
                .sort((a, b) => a[0].localeCompare(b[0]))
                .reduce((obj, [mois, stats]) => {
                    let totalHeures = stats.heuresHC + stats.heuresHNC;
                    obj[mois] = totalHeures > 0 ? (stats.heuresHC / totalHeures) * 100 : 0;
                    return obj;
                }, {});
        }

        // ===== ONGLET OPPORTUNIT√âS =====
        // Focus : Pipeline commercial et opportunit√©s - Page autonome
        function renderOpportunitesTab() {
            if (!opportunitesData.length) {
                document.getElementById('tab-opportunites').innerHTML = '<div class="no-data">Aucune donn√©e d\'opportunit√©s disponible</div>';
                return;
            }

            let opportunitesStats = calculateOpportunitesStats();

            let opportunitesHTML = `
                <div class="kpi-cards">
                    <div class="kpi-card">
                        <span class="kpi-icon">üéØ</span>
                        <div class="kpi-label">Total Opportunit√©s</div>
                        <div class="kpi-value">${opportunitesStats.totalOpportunites}</div>
                    </div>
                    <div class="kpi-card">
                        <span class="kpi-icon">üí∞</span>
                        <div class="kpi-label">Valeur Totale</div>
                        <div class="kpi-value">${opportunitesStats.valeurTotale.toLocaleString()} XAF</div>
                    </div>
                    <div class="kpi-card">
                        <span class="kpi-icon">üìä</span>
                        <div class="kpi-label">Taux de Conversion</div>
                        <div class="kpi-value">${opportunitesStats.tauxConversion.toFixed(1)}%</div>
                    </div>
                    <div class="kpi-card">
                        <span class="kpi-icon">üìà</span>
                        <div class="kpi-label">Valeur Moyenne</div>
                        <div class="kpi-value">${opportunitesStats.valeurMoyenne.toLocaleString()} XAF</div>
                    </div>
                    <div class="kpi-card">
                        <span class="kpi-icon">üèÜ</span>
                        <div class="kpi-label">Opportunit√©s Gagn√©es</div>
                        <div class="kpi-value">${opportunitesStats.opportunitesGagnees}</div>
                    </div>
                    <div class="kpi-card">
                        <span class="kpi-icon">‚è≥</span>
                        <div class="kpi-label">En Cours</div>
                        <div class="kpi-value">${opportunitesStats.enCours}</div>
                    </div>
                </div>
                
                <!-- Filtres sp√©cifiques aux opportunit√©s -->
                <div class="filters-section" style="margin: 20px 0; padding: 15px; background: #f8f9fa; border-radius: 8px;">
                    <h3 style="margin-bottom: 15px; color: #333;">Filtres Opportunit√©s</h3>
                    <div class="filters-row">
                        <div class="filter-group">
                            <label for="opportuniteDivisionFilter">Division:</label>
                            <select id="opportuniteDivisionFilter">
                                <option value="">Toutes les divisions</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label for="opportuniteStatutFilter">Statut:</label>
                            <select id="opportuniteStatutFilter">
                                <option value="">Tous les statuts</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label for="opportuniteResponsableFilter">Responsable:</label>
                            <select id="opportuniteResponsableFilter">
                                <option value="">Tous les responsables</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label for="opportuniteSecteurFilter">Secteur:</label>
                            <select id="opportuniteSecteurFilter">
                                <option value="">Tous les secteurs</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label for="opportuniteTypeFilter">Type:</label>
                            <select id="opportuniteTypeFilter">
                                <option value="">Tous les types</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label for="opportuniteInitiativeFilter">Initiative:</label>
                            <select id="opportuniteInitiativeFilter">
                                <option value="">Toutes les initiatives</option>
                            </select>
                        </div>
                    </div>
                </div>
                
                <div class="charts-row">
                    <div class="chart-container">
                        <div class="section-title">Opportunit√©s par Division</div>
                        <canvas id="opportunitesChartDivision"></canvas>
                    </div>
                    <div class="chart-container">
                        <div class="section-title">R√©partition par Statut</div>
                        <canvas id="opportunitesChartStatut"></canvas>
                    </div>
                </div>
                <div class="charts-row">
                    <div class="chart-container">
                        <div class="section-title">Valeur par Secteur</div>
                        <canvas id="opportunitesChartSecteur"></canvas>
                    </div>
                    <div class="chart-container">
                        <div class="section-title">Top Responsables</div>
                        <canvas id="opportunitesChartResponsable"></canvas>
                    </div>
                </div>
                <div class="chart-container" style="margin-top: 20px;">
                    <div class="section-title">Pipeline Commercial</div>
                    <table id="opportunitesTable">
                        <thead>
                            <tr>
                                <th>Client</th>
                                <th>Opportunit√©</th>
                                <th>Division</th>
                                <th>Responsable</th>
                                <th>Valeur</th>
                                <th>Probabilit√©</th>
                                <th>Statut</th>
                                <th>Secteur</th>
                                <th>Type</th>
                                <th>Date Insertion</th>
                                <th>Derni√®re Action</th>
                                <th>Prochaine Action</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${generateOpportunitesTable()}
                        </tbody>
                    </table>
                </div>
            `;

            document.getElementById('tab-opportunites').innerHTML = opportunitesHTML;

            // Initialiser les filtres sp√©cifiques aux opportunit√©s
            setupOpportunitesFilters();
            
            // Appliquer les filtres initiaux
            applyOpportunitesFilters();

            // Rendu des graphiques
            renderChart('opportunitesChartDivision', getOpportunitesByDivision(), 'bar', 'Division', 'Valeur (XAF)');
            renderChart('opportunitesChartStatut', getOpportunitesByStatut(), 'doughnut', 'Statut', 'Nombre');
            renderChart('opportunitesChartSecteur', getOpportunitesBySecteur(), 'bar', 'Secteur', 'Valeur (XAF)');
            renderChart('opportunitesChartResponsable', getOpportunitesByResponsable(), 'bar', 'Responsable', 'Valeur (XAF)');
        }

        function calculateOpportunitesStats() {
            let totalOpportunites = opportunitesData.length;
            let valeurTotale = opportunitesData.reduce((sum, opp) => {
                let valeur = parseFloat(opp['cout']?.replace(/\s/g, '') || '0');
                return sum + valeur;
            }, 0);
            let valeurMoyenne = totalOpportunites > 0 ? valeurTotale / totalOpportunites : 0;
            
            let oppGagnees = opportunitesData.filter(opp => 
                opp['Statut']?.toLowerCase().includes('win') || 
                opp['Statut']?.toLowerCase().includes('gagn√©')
            ).length;
            let tauxConversion = totalOpportunites > 0 ? (oppGagnees / totalOpportunites) * 100 : 0;

            return {
                totalOpportunites,
                valeurTotale,
                valeurMoyenne,
                tauxConversion,
                opportunitesGagnees: oppGagnees,
                enCours: totalOpportunites - oppGagnees
            };
        }

        function getOpportunitesByDivision() {
            let divisionStats = {};
            opportunitesData.forEach(opp => {
                let division = opp['Division'] || 'Non d√©fini';
                let valeur = parseFloat(opp['cout']?.replace(/\s/g, '') || '0');
                
                if (!divisionStats[division]) {
                    divisionStats[division] = 0;
                }
                divisionStats[division] += valeur;
            });

            return Object.entries(divisionStats)
                .sort((a, b) => b[1] - a[1])
                .reduce((obj, [division, valeur]) => {
                    obj[division] = valeur;
                    return obj;
                }, {});
        }

        function getOpportunitesByStatut() {
            let statutStats = {};
            opportunitesData.forEach(opp => {
                let statut = opp['Statut'] || 'Non d√©fini';
                
                if (!statutStats[statut]) {
                    statutStats[statut] = 0;
                }
                statutStats[statut]++;
            });

            return Object.entries(statutStats).map(([statut, count]) => ({
                label: statut,
                value: count
            }));
        }

        function getOpportunitesBySecteur() {
            let secteurStats = {};
            opportunitesData.forEach(opp => {
                let secteur = opp['Secteur'] || 'Non d√©fini';
                let valeur = parseFloat(opp['cout']?.replace(/\s/g, '') || '0');
                
                if (!secteurStats[secteur]) {
                    secteurStats[secteur] = 0;
                }
                secteurStats[secteur] += valeur;
            });

            return Object.entries(secteurStats)
                .sort((a, b) => b[1] - a[1])
                .reduce((obj, [secteur, valeur]) => {
                    obj[secteur] = valeur;
                    return obj;
                }, {});
        }

        function getOpportunitesByResponsable() {
            let responsableStats = {};
            opportunitesData.forEach(opp => {
                let responsable = opp['Responsable'] || 'Non d√©fini';
                let valeur = parseFloat(opp['cout']?.replace(/\s/g, '') || '0');
                
                if (!responsableStats[responsable]) {
                    responsableStats[responsable] = 0;
                }
                responsableStats[responsable] += valeur;
            });

            return Object.entries(responsableStats)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10) // Top 10 responsables
                .reduce((obj, [responsable, valeur]) => {
                    obj[responsable] = valeur;
                    return obj;
                }, {});
        }

        function generateOpportunitesTable() {
            const dataToUse = filteredOpportunitesData.length > 0 ? filteredOpportunitesData : opportunitesData;
            return dataToUse
                .sort((a, b) => {
                    let valeurA = parseFloat(a['cout']?.replace(/\s/g, '') || '0');
                    let valeurB = parseFloat(b['cout']?.replace(/\s/g, '') || '0');
                    return valeurB - valeurA;
                })
                .map(opp => `
                    <tr>
                        <td>${opp['Client'] || ''}</td>
                        <td>${opp['Opportunite'] || ''}</td>
                        <td>${opp['Division'] || ''}</td>
                        <td>${opp['Responsable'] || ''}</td>
                        <td>${formatCurrency(opp['cout'])}</td>
                        <td>${opp['% probabilit√© Succ√®s'] || '0%'}</td>
                        <td>${opp['Statut'] || ''}</td>
                        <td>${opp['Secteur'] || ''}</td>
                        <td>${opp['Type'] || ''}</td>
                        <td>${opp['Date Insertion'] || ''}</td>
                        <td>${opp['Date Derni√®re action'] || ''}</td>
                        <td>${opp['Date prochaine action'] || ''}</td>
                    </tr>
                `).join('');
        }

        // Variables pour les donn√©es filtr√©es des opportunit√©s
        let filteredOpportunitesData = [];

        function setupOpportunitesFilters() {
            // R√©cup√©rer les valeurs uniques pour chaque filtre
            let divisions = [...new Set(opportunitesData.map(opp => opp['Division']).filter(Boolean))];
            let statuts = [...new Set(opportunitesData.map(opp => opp['Statut']).filter(Boolean))];
            let responsables = [...new Set(opportunitesData.map(opp => opp['Responsable']).filter(Boolean))];
            let secteurs = [...new Set(opportunitesData.map(opp => opp['Secteur']).filter(Boolean))];
            let types = [...new Set(opportunitesData.map(opp => opp['Type']).filter(Boolean))];
            let initiatives = [...new Set(opportunitesData.map(opp => opp['Initiative']).filter(Boolean))];

            // Remplir les options des filtres
            populateSelect('opportuniteDivisionFilter', divisions);
            populateSelect('opportuniteStatutFilter', statuts);
            populateSelect('opportuniteResponsableFilter', responsables);
            populateSelect('opportuniteSecteurFilter', secteurs);
            populateSelect('opportuniteTypeFilter', types);
            populateSelect('opportuniteInitiativeFilter', initiatives);

            // Ajouter les event listeners
            document.getElementById('opportuniteDivisionFilter').addEventListener('change', applyOpportunitesFilters);
            document.getElementById('opportuniteStatutFilter').addEventListener('change', applyOpportunitesFilters);
            document.getElementById('opportuniteResponsableFilter').addEventListener('change', applyOpportunitesFilters);
            document.getElementById('opportuniteSecteurFilter').addEventListener('change', applyOpportunitesFilters);
            document.getElementById('opportuniteTypeFilter').addEventListener('change', applyOpportunitesFilters);
            document.getElementById('opportuniteInitiativeFilter').addEventListener('change', applyOpportunitesFilters);
        }

        function populateSelect(selectId, options) {
            const select = document.getElementById(selectId);
            if (!select) return;
            
            options.forEach(option => {
                const optionElement = document.createElement('option');
                optionElement.value = option;
                optionElement.textContent = option;
                select.appendChild(optionElement);
            });
        }

        function applyOpportunitesFilters() {
            const divisionFilter = document.getElementById('opportuniteDivisionFilter').value;
            const statutFilter = document.getElementById('opportuniteStatutFilter').value;
            const responsableFilter = document.getElementById('opportuniteResponsableFilter').value;
            const secteurFilter = document.getElementById('opportuniteSecteurFilter').value;
            const typeFilter = document.getElementById('opportuniteTypeFilter').value;
            const initiativeFilter = document.getElementById('opportuniteInitiativeFilter').value;

            filteredOpportunitesData = opportunitesData.filter(opp => {
                return (!divisionFilter || opp['Division'] === divisionFilter) &&
                       (!statutFilter || opp['Statut'] === statutFilter) &&
                       (!responsableFilter || opp['Responsable'] === responsableFilter) &&
                       (!secteurFilter || opp['Secteur'] === secteurFilter) &&
                       (!typeFilter || opp['Type'] === typeFilter) &&
                       (!initiativeFilter || opp['Initiative'] === initiativeFilter);
            });

            // Mettre √† jour les graphiques avec les donn√©es filtr√©es
            renderOpportunitesCharts();
            
            // Mettre √† jour le tableau
            const tbody = document.querySelector('#opportunitesTable tbody');
            if (tbody) {
                tbody.innerHTML = generateOpportunitesTable();
            }
        }

        function renderOpportunitesCharts() {
            // Utiliser filteredOpportunitesData au lieu de opportunitesData
            renderChart('opportunitesChartDivision', getOpportunitesByDivisionFiltered(), 'bar', 'Division', 'Valeur (XAF)');
            renderChart('opportunitesChartStatut', getOpportunitesByStatutFiltered(), 'doughnut', 'Statut', 'Nombre');
            renderChart('opportunitesChartSecteur', getOpportunitesBySecteurFiltered(), 'bar', 'Secteur', 'Valeur (XAF)');
            renderChart('opportunitesChartResponsable', getOpportunitesByResponsableFiltered(), 'bar', 'Responsable', 'Valeur (XAF)');
        }

        // Fonctions de calcul avec donn√©es filtr√©es
        function getOpportunitesByDivisionFiltered() {
            let divisionStats = {};
            filteredOpportunitesData.forEach(opp => {
                let division = opp['Division'] || 'Non d√©fini';
                let valeur = parseFloat(opp['cout']?.replace(/\s/g, '') || '0');
                
                if (!divisionStats[division]) {
                    divisionStats[division] = 0;
                }
                divisionStats[division] += valeur;
            });

            return Object.entries(divisionStats)
                .sort((a, b) => b[1] - a[1])
                .reduce((obj, [division, valeur]) => {
                    obj[division] = valeur;
                    return obj;
                }, {});
        }

        function getOpportunitesByStatutFiltered() {
            let statutStats = {};
            filteredOpportunitesData.forEach(opp => {
                let statut = opp['Statut'] || 'Non d√©fini';
                
                if (!statutStats[statut]) {
                    statutStats[statut] = 0;
                }
                statutStats[statut]++;
            });

            return Object.entries(statutStats).map(([statut, count]) => ({
                label: statut,
                value: count
            }));
        }

        function getOpportunitesBySecteurFiltered() {
            let secteurStats = {};
            filteredOpportunitesData.forEach(opp => {
                let secteur = opp['Secteur'] || 'Non d√©fini';
                let valeur = parseFloat(opp['cout']?.replace(/\s/g, '') || '0');
                
                if (!secteurStats[secteur]) {
                    secteurStats[secteur] = 0;
                }
                secteurStats[secteur] += valeur;
            });

            return Object.entries(secteurStats)
                .sort((a, b) => b[1] - a[1])
                .reduce((obj, [secteur, valeur]) => {
                    obj[secteur] = valeur;
                    return obj;
                }, {});
        }

        function getOpportunitesByResponsableFiltered() {
            let responsableStats = {};
            filteredOpportunitesData.forEach(opp => {
                let responsable = opp['Responsable'] || 'Non d√©fini';
                let valeur = parseFloat(opp['cout']?.replace(/\s/g, '') || '0');
                
                if (!responsableStats[responsable]) {
                    responsableStats[responsable] = 0;
                }
                responsableStats[responsable] += valeur;
            });

            return Object.entries(responsableStats)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10) // Top 10 responsables
                .reduce((obj, [responsable, valeur]) => {
                    obj[responsable] = valeur;
                    return obj;
                }, {});
        }

        // ===== ONGLET OPPORTUNIT√âS =====
        // Focus : Pipeline commercial et opportunit√©s - Page autonome
        function renderOpportunitesTab() {
            if (!opportunitesData.length) {
                document.getElementById('tab-opportunites').innerHTML = '<div class="no-data">Aucune donn√©e d\'opportunit√©s disponible</div>';
                return;
            }

            let opportunitesStats = calculateOpportunitesStats();

            let opportunitesHTML = `
                <div class="kpi-cards">
                    <div class="kpi-card">
                        <span class="kpi-icon">üéØ</span>
                        <div class="kpi-label">Total Opportunit√©s</div>
                        <div class="kpi-value">${opportunitesStats.totalOpportunites}</div>
                    </div>
                    <div class="kpi-card">
                        <span class="kpi-icon">üí∞</span>
                        <div class="kpi-label">Valeur Totale</div>
                        <div class="kpi-value">${opportunitesStats.valeurTotale.toLocaleString()} XAF</div>
                    </div>
                    <div class="kpi-card">
                        <span class="kpi-icon">üìä</span>
                        <div class="kpi-label">Taux de Conversion</div>
                        <div class="kpi-value">${opportunitesStats.tauxConversion.toFixed(1)}%</div>
                    </div>
                    <div class="kpi-card">
                        <span class="kpi-icon">üìà</span>
                        <div class="kpi-label">Valeur Moyenne</div>
                        <div class="kpi-value">${opportunitesStats.valeurMoyenne.toLocaleString()} XAF</div>
                    </div>
                    <div class="kpi-card">
                        <span class="kpi-icon">üèÜ</span>
                        <div class="kpi-label">Opportunit√©s Gagn√©es</div>
                        <div class="kpi-value">${opportunitesStats.opportunitesGagnees}</div>
                    </div>
                    <div class="kpi-card">
                        <span class="kpi-icon">‚è≥</span>
                        <div class="kpi-label">En Cours</div>
                        <div class="kpi-value">${opportunitesStats.enCours}</div>
                    </div>
                </div>
                
                <!-- Filtres sp√©cifiques aux opportunit√©s -->
                <div class="filters-section" style="margin: 20px 0; padding: 15px; background: #f8f9fa; border-radius: 8px;">
                    <h3 style="margin-bottom: 15px; color: #333;">Filtres Opportunit√©s</h3>
                    <div class="filters-row">
                        <div class="filter-group">
                            <label for="opportuniteDivisionFilter">Division:</label>
                            <select id="opportuniteDivisionFilter">
                                <option value="">Toutes les divisions</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label for="opportuniteStatutFilter">Statut:</label>
                            <select id="opportuniteStatutFilter">
                                <option value="">Tous les statuts</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label for="opportuniteResponsableFilter">Responsable:</label>
                            <select id="opportuniteResponsableFilter">
                                <option value="">Tous les responsables</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label for="opportuniteSecteurFilter">Secteur:</label>
                            <select id="opportuniteSecteurFilter">
                                <option value="">Tous les secteurs</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label for="opportuniteTypeFilter">Type:</label>
                            <select id="opportuniteTypeFilter">
                                <option value="">Tous les types</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label for="opportuniteInitiativeFilter">Initiative:</label>
                            <select id="opportuniteInitiativeFilter">
                                <option value="">Toutes les initiatives</option>
                            </select>
                        </div>
                    </div>
                </div>
                
                <div class="charts-row">
                    <div class="chart-container">
                        <div class="section-title">Opportunit√©s par Division</div>
                        <canvas id="opportunitesChartDivision"></canvas>
                    </div>
                    <div class="chart-container">
                        <div class="section-title">R√©partition par Statut</div>
                        <canvas id="opportunitesChartStatut"></canvas>
                    </div>
                </div>
                <div class="charts-row">
                    <div class="chart-container">
                        <div class="section-title">Valeur par Secteur</div>
                        <canvas id="opportunitesChartSecteur"></canvas>
                    </div>
                    <div class="chart-container">
                        <div class="section-title">Top Responsables</div>
                        <canvas id="opportunitesChartResponsable"></canvas>
                    </div>
                </div>
                <div class="chart-container" style="margin-top: 20px;">
                    <div class="section-title">Pipeline Commercial</div>
                    <table id="opportunitesTable">
                        <thead>
                            <tr>
                                <th>Client</th>
                                <th>Opportunit√©</th>
                                <th>Division</th>
                                <th>Responsable</th>
                                <th>Valeur</th>
                                <th>Probabilit√©</th>
                                <th>Statut</th>
                                <th>Secteur</th>
                                <th>Type</th>
                                <th>Date Insertion</th>
                                <th>Derni√®re Action</th>
                                <th>Prochaine Action</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${generateOpportunitesTable()}
                        </tbody>
                    </table>
                </div>
            `;

            document.getElementById('tab-opportunites').innerHTML = opportunitesHTML;

            // Initialiser les filtres sp√©cifiques aux opportunit√©s
            setupOpportunitesFilters();
            
            // Appliquer les filtres initiaux
            applyOpportunitesFilters();

            // Rendu des graphiques
            renderChart('opportunitesChartDivision', getOpportunitesByDivision(), 'bar', 'Division', 'Valeur (XAF)');
            renderChart('opportunitesChartStatut', getOpportunitesByStatut(), 'doughnut', 'Statut', 'Nombre');
            renderChart('opportunitesChartSecteur', getOpportunitesBySecteur(), 'bar', 'Secteur', 'Valeur (XAF)');
            renderChart('opportunitesChartResponsable', getOpportunitesByResponsable(), 'bar', 'Responsable', 'Valeur (XAF)');
        }

        // ===== FONCTIONS FACTURATION =====
        function calculateFacturationStats() {
            let totalFactures = facturesData.length;
            let montantFacture = facturesData.reduce((sum, facture) => {
                let montant = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                return sum + montant;
            }, 0);
            let montantEncaisse = facturesData.reduce((sum, facture) => {
                let montant = parseFloat(facture['Montant Encaiss√©']?.replace(/\s/g, '') || '0');
                return sum + montant;
            }, 0);
            let tauxEncaissement = montantFacture > 0 ? (montantEncaisse / montantFacture) * 100 : 0;

            return {
                totalFactures,
                montantFacture,
                montantEncaisse,
                tauxEncaissement
            };
        }

        function getFacturationByDivision() {
            let divisionStats = {};
            facturesData.forEach(facture => {
                let division = facture['Division'] || 'Non d√©fini';
                let montant = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                
                if (!divisionStats[division]) {
                    divisionStats[division] = 0;
                }
                divisionStats[division] += montant;
            });

            return Object.entries(divisionStats)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10)
                .map(([division, montant]) => ({
                    label: division,
                    value: montant
                }));
        }

        function getFacturationByEtat() {
            let etatStats = {};
            facturesData.forEach(facture => {
                let montantFacture = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                let montantEncaisse = parseFloat(facture['Montant Encaiss√©']?.replace(/\s/g, '') || '0');
                let solde = montantFacture - montantEncaisse;
                let etat = solde === 0 ? 'Pay√©' : solde > 0 ? 'En attente' : 'Surpay√©';
                
                if (!etatStats[etat]) {
                    etatStats[etat] = 0;
                }
                etatStats[etat]++;
            });

            return Object.entries(etatStats).map(([etat, count]) => ({
                label: etat,
                value: count
            }));
        }

        function generateFacturationTable() {
            return facturesData.map(facture => {
                let montantFacture = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                let montantEncaisse = parseFloat(facture['Montant Encaiss√©']?.replace(/\s/g, '') || '0');
                let solde = montantFacture - montantEncaisse;
                let etat = solde === 0 ? 'Pay√©' : solde > 0 ? 'En attente' : 'Surpay√©';
                
                return `
                    <tr>
                        <td>${facture['Client'] || ''}</td>
                        <td>${facture['Mission'] || ''}</td>
                        <td>${facture['Division'] || ''}</td>
                        <td>${montantFacture.toLocaleString()} XAF</td>
                        <td>${montantEncaisse.toLocaleString()} XAF</td>
                        <td>${solde.toLocaleString()} XAF</td>
                        <td>${etat}</td>
                    </tr>
                `;
            }).join('');
        }

        // ===== FONCTIONS RENTABILIT√â =====
        function calculateRentabiliteStats() {
            // Calculer les co√ªts √† partir des donn√©es TRS filtr√©es
            let coutTotal = calculateTotalCost();
            
            // Calculer le CA √† partir des factures
            let caTotal = facturesData.reduce((sum, facture) => {
                let montant = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                return sum + montant;
            }, 0);
            
            let margeBrute = caTotal - coutTotal;
            let tauxMarge = caTotal > 0 ? (margeBrute / caTotal) * 100 : 0;
            
            // Nouveaux KPIs
            let roiGlobal = coutTotal > 0 ? (margeBrute / coutTotal) * 100 : 0;
            
            // Calculer le taux de rentabilit√© (missions rentables / total missions)
            let missionStats = {};
            filteredData.forEach(row => {
                let mission = row['Missions'] || 'Non d√©fini';
                if (!missionStats[mission]) {
                    missionStats[mission] = { cout: 0, ca: 0 };
                }
                if (row['Type Heure'] === 'HC') {
                    let heures = parseFloat(row['Heures']) || 0;
                    let taux = gradeToTaux[row['Grade']] || 0;
                    missionStats[mission].cout += heures * taux;
                }
            });
            
            facturesData.forEach(facture => {
                let mission = facture['Mission'] || 'Non d√©fini';
                let montant = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                if (!missionStats[mission]) {
                    missionStats[mission] = { cout: 0, ca: 0 };
                }
                missionStats[mission].ca += montant;
            });
            
            let missionsRentables = Object.values(missionStats).filter(stats => (stats.ca - stats.cout) > 0).length;
            let totalMissions = Object.keys(missionStats).length;
            let tauxRentabilite = totalMissions > 0 ? (missionsRentables / totalMissions) * 100 : 0;
            
            // CA moyen par mission
            let missionsFacturees = facturesData.length;
            let caMoyen = missionsFacturees > 0 ? caTotal / missionsFacturees : 0;

            return {
                caTotal,
                coutTotal,
                margeBrute,
                tauxMarge,
                roiGlobal,
                tauxRentabilite,
                caMoyen
            };
        }

        function getRentabiliteByMission() {
            let missionStats = {};
            
            // Calculer les co√ªts par mission (uniquement heures HC)
            filteredData.forEach(row => {
                let mission = row['Missions'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                let taux = gradeToTaux[row['Grade']] || 0;
                
                if (!missionStats[mission]) {
                    missionStats[mission] = { cout: 0, ca: 0 };
                }
                
                // Ne calculer le co√ªt que pour les heures HC
                if (row['Type Heure'] === 'HC') {
                    let cout = heures * taux;
                    missionStats[mission].cout += cout;
                }
            });
            
            // Ajouter les CA par mission depuis les factures
            facturesData.forEach(facture => {
                let mission = facture['Mission'] || 'Non d√©fini';
                let montant = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                
                if (!missionStats[mission]) {
                    missionStats[mission] = { cout: 0, ca: 0 };
                }
                missionStats[mission].ca += montant;
            });

            return Object.entries(missionStats)
                .map(([mission, stats]) => ({
                    label: mission,
                    value: stats.ca - stats.cout
                }))
                .sort((a, b) => b.value - a.value)
                .slice(0, 10);
        }

        function getRentabiliteByDivision() {
            let divisionStats = {};
            
            // Calculer les co√ªts par division (uniquement heures HC)
            filteredData.forEach(row => {
                let division = row['Division'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                let taux = gradeToTaux[row['Grade']] || 0;
                
                if (!divisionStats[division]) {
                    divisionStats[division] = { cout: 0, ca: 0 };
                }
                
                // Ne calculer le co√ªt que pour les heures HC
                if (row['Type Heure'] === 'HC') {
                    let cout = heures * taux;
                    divisionStats[division].cout += cout;
                }
            });
            
            // Ajouter les CA par division depuis les factures
            facturesData.forEach(facture => {
                let division = facture['Division'] || 'Non d√©fini';
                let montant = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                
                if (!divisionStats[division]) {
                    divisionStats[division] = { cout: 0, ca: 0 };
                }
                divisionStats[division].ca += montant;
            });

            return Object.entries(divisionStats)
                .map(([division, stats]) => ({
                    label: division,
                    value: stats.ca - stats.cout
                }))
                .sort((a, b) => b.value - a.value);
        }

        function getRentabiliteByMonth() {
            let monthStats = {};
            
            // Calculer les marges par mois
            filteredData.forEach(row => {
                let mois = row['Mois'] || 'Non d√©fini';
                let mission = row['Missions'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                let taux = gradeToTaux[row['Grade']] || 0;
                
                if (!monthStats[mois]) {
                    monthStats[mois] = { cout: 0, ca: 0 };
                }
                
                if (row['Type Heure'] === 'HC') {
                    let cout = heures * taux;
                    monthStats[mois].cout += cout;
                }
            });
            
            // Ajouter les CA par mois depuis les factures
            facturesData.forEach(facture => {
                let date = facture['Date'] || '';
                let mois = date.split('/')[1] || 'Non d√©fini'; // Extraire le mois de la date
                let montant = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                
                if (!monthStats[mois]) {
                    monthStats[mois] = { cout: 0, ca: 0 };
                }
                monthStats[mois].ca += montant;
            });
            
            return Object.entries(monthStats)
                .sort((a, b) => a[0].localeCompare(b[0]))
                .reduce((obj, [mois, stats]) => {
                    obj[mois] = stats.ca - stats.cout;
                    return obj;
                }, {});
        }

        function getRentabiliteByMarges() {
            let missionStats = {};
            
            // Calculer les marges par mission
            filteredData.forEach(row => {
                let mission = row['Missions'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                let taux = gradeToTaux[row['Grade']] || 0;
                
                if (!missionStats[mission]) {
                    missionStats[mission] = { cout: 0, ca: 0 };
                }
                
                if (row['Type Heure'] === 'HC') {
                    let cout = heures * taux;
                    missionStats[mission].cout += cout;
                }
            });
            
            facturesData.forEach(facture => {
                let mission = facture['Mission'] || 'Non d√©fini';
                let montant = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                
                if (!missionStats[mission]) {
                    missionStats[mission] = { cout: 0, ca: 0 };
                }
                missionStats[mission].ca += montant;
            });
            
            // Cat√©goriser les marges
            let margeCategories = {
                'D√©ficitaire (< 0)': 0,
                'Faible (0-50k)': 0,
                'Moyenne (50k-200k)': 0,
                '√âlev√©e (200k-500k)': 0,
                'Tr√®s √©lev√©e (> 500k)': 0
            };
            
            Object.values(missionStats).forEach(stats => {
                let marge = stats.ca - stats.cout;
                if (marge < 0) {
                    margeCategories['D√©ficitaire (< 0)']++;
                } else if (marge < 50000) {
                    margeCategories['Faible (0-50k)']++;
                } else if (marge < 200000) {
                    margeCategories['Moyenne (50k-200k)']++;
                } else if (marge < 500000) {
                    margeCategories['√âlev√©e (200k-500k)']++;
                } else {
                    margeCategories['Tr√®s √©lev√©e (> 500k)']++;
                }
            });
            
            return margeCategories;
        }

        function generateRentabiliteTable() {
            let missionStats = {};
            
            // Calculer les co√ªts par mission (uniquement heures HC)
            filteredData.forEach(row => {
                let mission = row['Missions'] || 'Non d√©fini';
                let division = row['Division'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                let taux = gradeToTaux[row['Grade']] || 0;
                
                if (!missionStats[mission]) {
                    missionStats[mission] = { 
                        division: division,
                        cout: 0, 
                        ca: 0,
                        heuresHC: 0
                    };
                }
                
                // Ne calculer le co√ªt que pour les heures HC
                if (row['Type Heure'] === 'HC') {
                    let cout = heures * taux;
                    missionStats[mission].cout += cout;
                    missionStats[mission].heuresHC += heures;
                }
            });
            
            // Ajouter les CA par mission depuis les factures
            facturesData.forEach(facture => {
                let mission = facture['Mission'] || 'Non d√©fini';
                let montant = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                
                if (!missionStats[mission]) {
                    missionStats[mission] = { 
                        division: facture['Division'] || 'Non d√©fini',
                        cout: 0, 
                        ca: 0,
                        heuresHC: 0
                    };
                }
                missionStats[mission].ca += montant;
            });

            return Object.entries(missionStats)
                .map(([mission, stats]) => {
                    let marge = stats.ca - stats.cout;
                    let tauxMarge = stats.ca > 0 ? (marge / stats.ca) * 100 : 0;
                    let roi = stats.cout > 0 ? (marge / stats.cout) * 100 : 0;
                    let coutParHeure = stats.heuresHC > 0 ? stats.cout / stats.heuresHC : 0;
                    let caParHeure = stats.heuresHC > 0 ? stats.ca / stats.heuresHC : 0;
                    let rentabilite = marge > 0 ? 'Rentable' : marge < 0 ? 'D√©ficitaire' : '√âquilibr√©';
                    
                    // Classes CSS pour les alertes
                    let alertClass = '';
                    if (marge < 0 || roi < 20) {
                        alertClass = 'alert-low-rentability';
                    }
                    
                    return `
                        <tr class="${alertClass}">
                            <td>${mission}</td>
                            <td>${stats.division}</td>
                            <td>${stats.heuresHC.toFixed(1)}h</td>
                            <td>${stats.cout.toLocaleString()} XAF</td>
                            <td>${stats.ca.toLocaleString()} XAF</td>
                            <td>${marge.toLocaleString()} XAF</td>
                            <td>${tauxMarge.toFixed(1)}%</td>
                            <td>${roi.toFixed(1)}%</td>
                            <td>${coutParHeure.toFixed(0)} XAF/h</td>
                            <td>${caParHeure.toFixed(0)} XAF/h</td>
                            <td>${rentabilite}</td>
                        </tr>
                    `;
                })
                .sort((a, b) => {
                    // Trier par rentabilit√© d√©croissante
                    let margeA = parseFloat(a.match(/td>([^<]+) XAF<\/td>/)[1].replace(/\s/g, ''));
                    let margeB = parseFloat(b.match(/td>([^<]+) XAF<\/td>/)[1].replace(/\s/g, ''));
                    return margeB - margeA;
                })
                .join('');
        }

        // ===== FONCTIONS PERFORMANCE =====
        function calculatePerformanceStats() {
            let collaborateurStats = {};
            
            filteredData.forEach(row => {
                let nom = row['Nom'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                let grade = row['Grade'] || 'Non d√©fini';
                let division = row['Division'] || 'Non d√©fini';
                let taux = gradeToTaux[grade] || 0;
                
                if (!collaborateurStats[nom]) {
                    collaborateurStats[nom] = {
                        heures: 0,
                        heuresHC: 0,
                        heuresHNC: 0,
                        cout: 0,
                        grade: grade,
                        division: division
                    };
                }
                
                collaborateurStats[nom].heures += heures;
                
                // Ne calculer le co√ªt que pour les heures HC
                if (row['Type Heure'] === 'HC') {
                    let cout = heures * taux;
                    collaborateurStats[nom].cout += cout;
                    collaborateurStats[nom].heuresHC += heures;
                } else {
                    collaborateurStats[nom].heuresHNC += heures;
                }
            });

            let totalCollaborateurs = Object.keys(collaborateurStats).length;
            let totalHeures = Object.values(collaborateurStats).reduce((sum, stats) => sum + stats.heures, 0);
            let heuresMoyennes = totalCollaborateurs > 0 ? totalHeures / totalCollaborateurs : 0;
            
            // Calculer le taux de chargeabilit√© global
            let totalHeuresHC = Object.values(collaborateurStats).reduce((sum, stats) => sum + stats.heuresHC, 0);
            let totalHeuresHNC = Object.values(collaborateurStats).reduce((sum, stats) => sum + stats.heuresHNC, 0);
            let tauxChargeabilite = (totalHeuresHC + totalHeuresHNC) > 0 ? (totalHeuresHC / (totalHeuresHC + totalHeuresHNC)) * 100 : 0;
            
            // Trouver le collaborateur le plus efficace (ratio HNC/HC le plus faible)
            let plusEfficace = Object.entries(collaborateurStats)
                .filter(([nom, stats]) => stats.heuresHC > 0 && (stats.heuresHC + stats.heuresHNC) > 0) // Seulement ceux avec des heures HC et total > 0
                .sort((a, b) => {
                    let ratioA = a[1].heuresHNC / a[1].heuresHC;
                    let ratioB = b[1].heuresHNC / b[1].heuresHC;
                    return ratioA - ratioB; // Plus le ratio est faible, meilleur
                })[0];
            let plusEfficaceName = plusEfficace ? plusEfficace[0] : 'N/A';

            return {
                totalCollaborateurs,
                heuresMoyennes,
                tauxChargeabilite,
                plusEfficace: plusEfficaceName
            };
        }





        function generatePerformanceTable() {
            let collaborateurStats = {};
            
            filteredData.forEach(row => {
                let nom = row['Nom'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                let grade = row['Grade'] || 'Non d√©fini';
                let division = row['Division'] || 'Non d√©fini';
                
                if (!collaborateurStats[nom]) {
                    collaborateurStats[nom] = {
                        heures: 0,
                        heuresHC: 0,
                        heuresHNC: 0,
                        grade: grade,
                        division: division
                    };
                }
                
                collaborateurStats[nom].heures += heures;
                
                if (row['Type Heure'] === 'HC') {
                    collaborateurStats[nom].heuresHC += heures;
                } else {
                    collaborateurStats[nom].heuresHNC += heures;
                }
            });

            // Calculer la productivit√© moyenne pour la comparaison
            let productivites = Object.values(collaborateurStats)
                .filter(stats => stats.heuresHC > 0)
                .map(stats => stats.heuresHNC / stats.heuresHC);
            let productiviteMoyenne = productivites.length > 0 ? 
                productivites.reduce((sum, val) => sum + val, 0) / productivites.length : 0;

            return Object.entries(collaborateurStats)
                .map(([nom, stats]) => {
                    let tauxChargeabilite = (stats.heuresHC + stats.heuresHNC) > 0 ? 
                        (stats.heuresHC / (stats.heuresHC + stats.heuresHNC)) * 100 : 0;
                    let ratioHCHNC = stats.heuresHC > 0 ? stats.heuresHNC / stats.heuresHC : 0;
                    let productiviteRelative = productiviteMoyenne > 0 ? 
                        ((productiviteMoyenne - ratioHCHNC) / productiviteMoyenne) * 100 : 0;
                    
                    // D√©terminer le statut
                    let statut = '';
                    let alertClass = '';
                    if (ratioHCHNC > 1.5) {
                        statut = '‚ö†Ô∏è Sous-performant';
                        alertClass = 'alert-low-performance';
                    } else if (ratioHCHNC < 0.5) {
                        statut = '‚úÖ Excellent';
                        alertClass = 'alert-excellent-performance';
                    } else if (ratioHCHNC < 1) {
                        statut = 'üëç Bon';
                        alertClass = 'alert-good-performance';
                    } else {
                        statut = '‚ö†Ô∏è √Ä am√©liorer';
                        alertClass = 'alert-medium-performance';
                    }
                    
                    return `
                        <tr class="${alertClass}">
                            <td>${nom}</td>
                            <td>${stats.grade}</td>
                            <td>${stats.division}</td>
                            <td>${stats.heures.toFixed(1)}h</td>
                            <td>${stats.heuresHC.toFixed(1)}h</td>
                            <td>${stats.heuresHNC.toFixed(1)}h</td>
                            <td>${tauxChargeabilite.toFixed(1)}%</td>
                            <td>${ratioHCHNC.toFixed(2)}</td>
                            <td>${ratioHCHNC.toFixed(2)}</td>
                            <td>${productiviteRelative.toFixed(1)}%</td>
                            <td>${statut}</td>
                        </tr>
                    `;
                })
                .sort((a, b) => {
                    // Trier par ratio HNC/HC croissant (meilleur en premier)
                    let ratioA = parseFloat(a.match(/td>([^<]+)<\/td>/g)[7].replace(/<\/?td>/g, ''));
                    let ratioB = parseFloat(b.match(/td>([^<]+)<\/td>/g)[7].replace(/<\/?td>/g, ''));
                    return ratioA - ratioB;
                })
                .join('');
        }

        function getTopCollaborateursProductivite() {
            let collaborateurStats = {};
            
            filteredData.forEach(row => {
                let nom = row['Nom'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                
                if (!collaborateurStats[nom]) {
                    collaborateurStats[nom] = { heuresHC: 0, heuresHNC: 0 };
                }
                
                if (row['Type Heure'] === 'HC') {
                    collaborateurStats[nom].heuresHC += heures;
                } else {
                    collaborateurStats[nom].heuresHNC += heures;
                }
            });

            let result = Object.entries(collaborateurStats)
                .filter(([nom, stats]) => stats.heuresHC > 0 && (stats.heuresHC + stats.heuresHNC) > 0) // Seulement ceux avec des heures HC et total > 0
                .map(([nom, stats]) => {
                    let ratio = stats.heuresHNC / stats.heuresHC;
                    return {
                        label: nom.length > 15 ? nom.substring(0, 15) + '...' : nom,
                        value: ratio
                    };
                })
                .sort((a, b) => a.value - b.value) // Plus le ratio est faible, meilleur
                .slice(0, 5);
            
            // Convertir en format attendu par renderChart
            let chartData = {};
            result.forEach(item => {
                chartData[item.label] = item.value;
            });
            
            return chartData;
        }

        function getPerformanceByDivision() {
            let divisionStats = {};
            
            filteredData.forEach(row => {
                let division = row['Division'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                
                if (!divisionStats[division]) {
                    divisionStats[division] = { heuresHC: 0, heuresHNC: 0 };
                }
                
                if (row['Type Heure'] === 'HC') {
                    divisionStats[division].heuresHC += heures;
                } else {
                    divisionStats[division].heuresHNC += heures;
                }
            });

            let result = Object.entries(divisionStats)
                .filter(([division, stats]) => (stats.heuresHC + stats.heuresHNC) > 0) // Seulement les divisions avec des heures
                .map(([division, stats]) => {
                    let totalHeures = stats.heuresHC + stats.heuresHNC;
                    let tauxChargeabilite = (stats.heuresHC / totalHeures) * 100;
                    return {
                        label: division,
                        value: tauxChargeabilite
                    };
                })
                .sort((a, b) => b.value - a.value);
            
            // Convertir en format attendu par renderChart
            let chartData = {};
            result.forEach(item => {
                chartData[item.label] = item.value;
            });
            
            return chartData;
        }

        function getRepartitionHCHNC() {
            let totalHeuresHC = 0;
            let totalHeuresHNC = 0;
            
            filteredData.forEach(row => {
                let heures = parseFloat(row['Heures']) || 0;
                
                if (row['Type Heure'] === 'HC') {
                    totalHeuresHC += heures;
                } else {
                    totalHeuresHNC += heures;
                }
            });

            return {
                'Heures Chargeables': totalHeuresHC,
                'Heures Non-Chargeables': totalHeuresHNC
            };
        }

        function getPerformanceByMonth() {
            let monthStats = {};
            
            filteredData.forEach(row => {
                let mois = row['Mois'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                
                if (!monthStats[mois]) {
                    monthStats[mois] = { heuresHC: 0, heuresHNC: 0 };
                }
                
                if (row['Type Heure'] === 'HC') {
                    monthStats[mois].heuresHC += heures;
                } else {
                    monthStats[mois].heuresHNC += heures;
                }
            });

            return Object.entries(monthStats)
                .sort((a, b) => a[0].localeCompare(b[0]))
                .reduce((obj, [mois, stats]) => {
                    let totalHeures = stats.heuresHC + stats.heuresHNC;
                    obj[mois] = totalHeures > 0 ? (stats.heuresHC / totalHeures) * 100 : 0;
                    return obj;
                }, {});
        }

        // ===== ONGLET OPPORTUNIT√âS =====
        // Focus : Pipeline commercial et opportunit√©s - Page autonome
        function renderOpportunitesTab() {
            if (!opportunitesData.length) {
                document.getElementById('tab-opportunites').innerHTML = '<div class="no-data">Aucune donn√©e d\'opportunit√©s disponible</div>';
                return;
            }

            let opportunitesStats = calculateOpportunitesStats();

            let opportunitesHTML = `
                <div class="kpi-cards">
                    <div class="kpi-card">
                        <span class="kpi-icon">üéØ</span>
                        <div class="kpi-label">Total Opportunit√©s</div>
                        <div class="kpi-value">${opportunitesStats.totalOpportunites}</div>
                    </div>
                    <div class="kpi-card">
                        <span class="kpi-icon">üí∞</span>
                        <div class="kpi-label">Valeur Totale</div>
                        <div class="kpi-value">${opportunitesStats.valeurTotale.toLocaleString()} XAF</div>
                    </div>
                    <div class="kpi-card">
                        <span class="kpi-icon">üìä</span>
                        <div class="kpi-label">Taux de Conversion</div>
                        <div class="kpi-value">${opportunitesStats.tauxConversion.toFixed(1)}%</div>
                    </div>
                    <div class="kpi-card">
                        <span class="kpi-icon">üìà</span>
                        <div class="kpi-label">Valeur Moyenne</div>
                        <div class="kpi-value">${opportunitesStats.valeurMoyenne.toLocaleString()} XAF</div>
                    </div>
                    <div class="kpi-card">
                        <span class="kpi-icon">üèÜ</span>
                        <div class="kpi-label">Opportunit√©s Gagn√©es</div>
                        <div class="kpi-value">${opportunitesStats.opportunitesGagnees}</div>
                    </div>
                    <div class="kpi-card">
                        <span class="kpi-icon">‚è≥</span>
                        <div class="kpi-label">En Cours</div>
                        <div class="kpi-value">${opportunitesStats.enCours}</div>
                    </div>
                </div>
                
                <!-- Filtres sp√©cifiques aux opportunit√©s -->
                <div class="filters-section" style="margin: 20px 0; padding: 15px; background: #f8f9fa; border-radius: 8px;">
                    <h3 style="margin-bottom: 15px; color: #333;">Filtres Opportunit√©s</h3>
                    <div class="filters-row">
                        <div class="filter-group">
                            <label for="opportuniteDivisionFilter">Division:</label>
                            <select id="opportuniteDivisionFilter">
                                <option value="">Toutes les divisions</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label for="opportuniteStatutFilter">Statut:</label>
                            <select id="opportuniteStatutFilter">
                                <option value="">Tous les statuts</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label for="opportuniteResponsableFilter">Responsable:</label>
                            <select id="opportuniteResponsableFilter">
                                <option value="">Tous les responsables</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label for="opportuniteSecteurFilter">Secteur:</label>
                            <select id="opportuniteSecteurFilter">
                                <option value="">Tous les secteurs</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label for="opportuniteTypeFilter">Type:</label>
                            <select id="opportuniteTypeFilter">
                                <option value="">Tous les types</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label for="opportuniteInitiativeFilter">Initiative:</label>
                            <select id="opportuniteInitiativeFilter">
                                <option value="">Toutes les initiatives</option>
                            </select>
                        </div>
                    </div>
                </div>
                
                <div class="charts-row">
                    <div class="chart-container">
                        <div class="section-title">Opportunit√©s par Division</div>
                        <canvas id="opportunitesChartDivision"></canvas>
                    </div>
                    <div class="chart-container">
                        <div class="section-title">R√©partition par Statut</div>
                        <canvas id="opportunitesChartStatut"></canvas>
                    </div>
                </div>
                <div class="charts-row">
                    <div class="chart-container">
                        <div class="section-title">Valeur par Secteur</div>
                        <canvas id="opportunitesChartSecteur"></canvas>
                    </div>
                    <div class="chart-container">
                        <div class="section-title">Top Responsables</div>
                        <canvas id="opportunitesChartResponsable"></canvas>
                    </div>
                </div>
                <div class="chart-container" style="margin-top: 20px;">
                    <div class="section-title">Pipeline Commercial</div>
                    <table id="opportunitesTable">
                        <thead>
                            <tr>
                                <th>Client</th>
                                <th>Opportunit√©</th>
                                <th>Division</th>
                                <th>Responsable</th>
                                <th>Valeur</th>
                                <th>Probabilit√©</th>
                                <th>Statut</th>
                                <th>Secteur</th>
                                <th>Type</th>
                                <th>Date Insertion</th>
                                <th>Derni√®re Action</th>
                                <th>Prochaine Action</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${generateOpportunitesTable()}
                        </tbody>
                    </table>
                </div>
            `;

            document.getElementById('tab-opportunites').innerHTML = opportunitesHTML;

            // Initialiser les filtres sp√©cifiques aux opportunit√©s
            setupOpportunitesFilters();
            
            // Appliquer les filtres initiaux
            applyOpportunitesFilters();

            // Rendu des graphiques
            renderChart('opportunitesChartDivision', getOpportunitesByDivision(), 'bar', 'Division', 'Valeur (XAF)');
            renderChart('opportunitesChartStatut', getOpportunitesByStatut(), 'doughnut', 'Statut', 'Nombre');
            renderChart('opportunitesChartSecteur', getOpportunitesBySecteur(), 'bar', 'Secteur', 'Valeur (XAF)');
            renderChart('opportunitesChartResponsable', getOpportunitesByResponsable(), 'bar', 'Responsable', 'Valeur (XAF)');
        }

        // ===== FONCTIONS FACTURATION =====
        function calculateFacturationStats() {
            let totalFactures = facturesData.length;
            let montantFacture = facturesData.reduce((sum, facture) => {
                let montant = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                return sum + montant;
            }, 0);
            let montantEncaisse = facturesData.reduce((sum, facture) => {
                let montant = parseFloat(facture['Montant Encaiss√©']?.replace(/\s/g, '') || '0');
                return sum + montant;
            }, 0);
            let tauxEncaissement = montantFacture > 0 ? (montantEncaisse / montantFacture) * 100 : 0;

            return {
                totalFactures,
                montantFacture,
                montantEncaisse,
                tauxEncaissement
            };
        }

        function getFacturationByDivision() {
            let divisionStats = {};
            facturesData.forEach(facture => {
                let division = facture['Division'] || 'Non d√©fini';
                let montant = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                
                if (!divisionStats[division]) {
                    divisionStats[division] = 0;
                }
                divisionStats[division] += montant;
            });

            return Object.entries(divisionStats)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10)
                .map(([division, montant]) => ({
                    label: division,
                    value: montant
                }));
        }

        function getFacturationByEtat() {
            let etatStats = {};
            facturesData.forEach(facture => {
                let montantFacture = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                let montantEncaisse = parseFloat(facture['Montant Encaiss√©']?.replace(/\s/g, '') || '0');
                let solde = montantFacture - montantEncaisse;
                let etat = solde === 0 ? 'Pay√©' : solde > 0 ? 'En attente' : 'Surpay√©';
                
                if (!etatStats[etat]) {
                    etatStats[etat] = 0;
                }
                etatStats[etat]++;
            });

            return Object.entries(etatStats).map(([etat, count]) => ({
                label: etat,
                value: count
            }));
        }

        function generateFacturationTable() {
            return facturesData.map(facture => {
                let montantFacture = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                let montantEncaisse = parseFloat(facture['Montant Encaiss√©']?.replace(/\s/g, '') || '0');
                let solde = montantFacture - montantEncaisse;
                let etat = solde === 0 ? 'Pay√©' : solde > 0 ? 'En attente' : 'Surpay√©';
                
                return `
                    <tr>
                        <td>${facture['Client'] || ''}</td>
                        <td>${facture['Mission'] || ''}</td>
                        <td>${facture['Division'] || ''}</td>
                        <td>${montantFacture.toLocaleString()} XAF</td>
                        <td>${montantEncaisse.toLocaleString()} XAF</td>
                        <td>${solde.toLocaleString()} XAF</td>
                        <td>${etat}</td>
                    </tr>
                `;
            }).join('');
        }

        // ===== FONCTIONS RENTABILIT√â =====
        function calculateRentabiliteStats() {
            // Calculer les co√ªts √† partir des donn√©es TRS filtr√©es
            let coutTotal = calculateTotalCost();
            
            // Calculer le CA √† partir des factures
            let caTotal = facturesData.reduce((sum, facture) => {
                let montant = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                return sum + montant;
            }, 0);
            
            let margeBrute = caTotal - coutTotal;
            let tauxMarge = caTotal > 0 ? (margeBrute / caTotal) * 100 : 0;
            
            // Nouveaux KPIs
            let roiGlobal = coutTotal > 0 ? (margeBrute / coutTotal) * 100 : 0;
            
            // Calculer le taux de rentabilit√© (missions rentables / total missions)
            let missionStats = {};
            filteredData.forEach(row => {
                let mission = row['Missions'] || 'Non d√©fini';
                if (!missionStats[mission]) {
                    missionStats[mission] = { cout: 0, ca: 0 };
                }
                if (row['Type Heure'] === 'HC') {
                    let heures = parseFloat(row['Heures']) || 0;
                    let taux = gradeToTaux[row['Grade']] || 0;
                    missionStats[mission].cout += heures * taux;
                }
            });
            
            facturesData.forEach(facture => {
                let mission = facture['Mission'] || 'Non d√©fini';
                let montant = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                if (!missionStats[mission]) {
                    missionStats[mission] = { cout: 0, ca: 0 };
                }
                missionStats[mission].ca += montant;
            });
            
            let missionsRentables = Object.values(missionStats).filter(stats => (stats.ca - stats.cout) > 0).length;
            let totalMissions = Object.keys(missionStats).length;
            let tauxRentabilite = totalMissions > 0 ? (missionsRentables / totalMissions) * 100 : 0;
            
            // CA moyen par mission
            let missionsFacturees = facturesData.length;
            let caMoyen = missionsFacturees > 0 ? caTotal / missionsFacturees : 0;

            return {
                caTotal,
                coutTotal,
                margeBrute,
                tauxMarge,
                roiGlobal,
                tauxRentabilite,
                caMoyen
            };
        }

        function getRentabiliteByMission() {
            let missionStats = {};
            
            // Calculer les co√ªts par mission (uniquement heures HC)
            filteredData.forEach(row => {
                let mission = row['Missions'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                let taux = gradeToTaux[row['Grade']] || 0;
                
                if (!missionStats[mission]) {
                    missionStats[mission] = { cout: 0, ca: 0 };
                }
                
                // Ne calculer le co√ªt que pour les heures HC
                if (row['Type Heure'] === 'HC') {
                    let cout = heures * taux;
                    missionStats[mission].cout += cout;
                }
            });
            
            // Ajouter les CA par mission depuis les factures
            facturesData.forEach(facture => {
                let mission = facture['Mission'] || 'Non d√©fini';
                let montant = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                
                if (!missionStats[mission]) {
                    missionStats[mission] = { cout: 0, ca: 0 };
                }
                missionStats[mission].ca += montant;
            });

            return Object.entries(missionStats)
                .map(([mission, stats]) => ({
                    label: mission,
                    value: stats.ca - stats.cout
                }))
                .sort((a, b) => b.value - a.value)
                .slice(0, 10);
        }

        function getRentabiliteByDivision() {
            let divisionStats = {};
            
            // Calculer les co√ªts par division (uniquement heures HC)
            filteredData.forEach(row => {
                let division = row['Division'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                let taux = gradeToTaux[row['Grade']] || 0;
                
                if (!divisionStats[division]) {
                    divisionStats[division] = { cout: 0, ca: 0 };
                }
                
                // Ne calculer le co√ªt que pour les heures HC
                if (row['Type Heure'] === 'HC') {
                    let cout = heures * taux;
                    divisionStats[division].cout += cout;
                }
            });
            
            // Ajouter les CA par division depuis les factures
            facturesData.forEach(facture => {
                let division = facture['Division'] || 'Non d√©fini';
                let montant = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                
                if (!divisionStats[division]) {
                    divisionStats[division] = { cout: 0, ca: 0 };
                }
                divisionStats[division].ca += montant;
            });

            return Object.entries(divisionStats)
                .map(([division, stats]) => ({
                    label: division,
                    value: stats.ca - stats.cout
                }))
                .sort((a, b) => b.value - a.value);
        }

        function getRentabiliteByMonth() {
            let monthStats = {};
            
            // Calculer les marges par mois
            filteredData.forEach(row => {
                let mois = row['Mois'] || 'Non d√©fini';
                let mission = row['Missions'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                let taux = gradeToTaux[row['Grade']] || 0;
                
                if (!monthStats[mois]) {
                    monthStats[mois] = { cout: 0, ca: 0 };
                }
                
                if (row['Type Heure'] === 'HC') {
                    let cout = heures * taux;
                    monthStats[mois].cout += cout;
                }
            });
            
            // Ajouter les CA par mois depuis les factures
            facturesData.forEach(facture => {
                let date = facture['Date'] || '';
                let mois = date.split('/')[1] || 'Non d√©fini'; // Extraire le mois de la date
                let montant = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                
                if (!monthStats[mois]) {
                    monthStats[mois] = { cout: 0, ca: 0 };
                }
                monthStats[mois].ca += montant;
            });
            
            return Object.entries(monthStats)
                .sort((a, b) => a[0].localeCompare(b[0]))
                .reduce((obj, [mois, stats]) => {
                    obj[mois] = stats.ca - stats.cout;
                    return obj;
                }, {});
        }

        function getRentabiliteByMarges() {
            let missionStats = {};
            
            // Calculer les marges par mission
            filteredData.forEach(row => {
                let mission = row['Missions'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                let taux = gradeToTaux[row['Grade']] || 0;
                
                if (!missionStats[mission]) {
                    missionStats[mission] = { cout: 0, ca: 0 };
                }
                
                if (row['Type Heure'] === 'HC') {
                    let cout = heures * taux;
                    missionStats[mission].cout += cout;
                }
            });
            
            facturesData.forEach(facture => {
                let mission = facture['Mission'] || 'Non d√©fini';
                let montant = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                
                if (!missionStats[mission]) {
                    missionStats[mission] = { cout: 0, ca: 0 };
                }
                missionStats[mission].ca += montant;
            });
            
            // Cat√©goriser les marges
            let margeCategories = {
                'D√©ficitaire (< 0)': 0,
                'Faible (0-50k)': 0,
                'Moyenne (50k-200k)': 0,
                '√âlev√©e (200k-500k)': 0,
                'Tr√®s √©lev√©e (> 500k)': 0
            };
            
            Object.values(missionStats).forEach(stats => {
                let marge = stats.ca - stats.cout;
                if (marge < 0) {
                    margeCategories['D√©ficitaire (< 0)']++;
                } else if (marge < 50000) {
                    margeCategories['Faible (0-50k)']++;
                } else if (marge < 200000) {
                    margeCategories['Moyenne (50k-200k)']++;
                } else if (marge < 500000) {
                    margeCategories['√âlev√©e (200k-500k)']++;
                } else {
                    margeCategories['Tr√®s √©lev√©e (> 500k)']++;
                }
            });
            
            return margeCategories;
        }

        function generateRentabiliteTable() {
            let missionStats = {};
            
            // Calculer les co√ªts par mission (uniquement heures HC)
            filteredData.forEach(row => {
                let mission = row['Missions'] || 'Non d√©fini';
                let division = row['Division'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                let taux = gradeToTaux[row['Grade']] || 0;
                
                if (!missionStats[mission]) {
                    missionStats[mission] = { 
                        division: division,
                        cout: 0, 
                        ca: 0,
                        heuresHC: 0
                    };
                }
                
                // Ne calculer le co√ªt que pour les heures HC
                if (row['Type Heure'] === 'HC') {
                    let cout = heures * taux;
                    missionStats[mission].cout += cout;
                    missionStats[mission].heuresHC += heures;
                }
            });
            
            // Ajouter les CA par mission depuis les factures
            facturesData.forEach(facture => {
                let mission = facture['Mission'] || 'Non d√©fini';
                let montant = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                
                if (!missionStats[mission]) {
                    missionStats[mission] = { 
                        division: facture['Division'] || 'Non d√©fini',
                        cout: 0, 
                        ca: 0,
                        heuresHC: 0
                    };
                }
                missionStats[mission].ca += montant;
            });

            return Object.entries(missionStats)
                .map(([mission, stats]) => {
                    let marge = stats.ca - stats.cout;
                    let tauxMarge = stats.ca > 0 ? (marge / stats.ca) * 100 : 0;
                    let roi = stats.cout > 0 ? (marge / stats.cout) * 100 : 0;
                    let coutParHeure = stats.heuresHC > 0 ? stats.cout / stats.heuresHC : 0;
                    let caParHeure = stats.heuresHC > 0 ? stats.ca / stats.heuresHC : 0;
                    let rentabilite = marge > 0 ? 'Rentable' : marge < 0 ? 'D√©ficitaire' : '√âquilibr√©';
                    
                    // Classes CSS pour les alertes
                    let alertClass = '';
                    if (marge < 0 || roi < 20) {
                        alertClass = 'alert-low-rentability';
                    }
                    
                    return `
                        <tr class="${alertClass}">
                            <td>${mission}</td>
                            <td>${stats.division}</td>
                            <td>${stats.heuresHC.toFixed(1)}h</td>
                            <td>${stats.cout.toLocaleString()} XAF</td>
                            <td>${stats.ca.toLocaleString()} XAF</td>
                            <td>${marge.toLocaleString()} XAF</td>
                            <td>${tauxMarge.toFixed(1)}%</td>
                            <td>${roi.toFixed(1)}%</td>
                            <td>${coutParHeure.toFixed(0)} XAF/h</td>
                            <td>${caParHeure.toFixed(0)} XAF/h</td>
                            <td>${rentabilite}</td>
                        </tr>
                    `;
                })
                .sort((a, b) => {
                    // Trier par rentabilit√© d√©croissante
                    let margeA = parseFloat(a.match(/td>([^<]+) XAF<\/td>/)[1].replace(/\s/g, ''));
                    let margeB = parseFloat(b.match(/td>([^<]+) XAF<\/td>/)[1].replace(/\s/g, ''));
                    return margeB - margeA;
                })
                .join('');
        }

        // ===== FONCTIONS PERFORMANCE =====
        function calculatePerformanceStats() {
            let collaborateurStats = {};
            
            filteredData.forEach(row => {
                let nom = row['Nom'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                let grade = row['Grade'] || 'Non d√©fini';
                let division = row['Division'] || 'Non d√©fini';
                let taux = gradeToTaux[grade] || 0;
                
                if (!collaborateurStats[nom]) {
                    collaborateurStats[nom] = {
                        heures: 0,
                        heuresHC: 0,
                        heuresHNC: 0,
                        cout: 0,
                        grade: grade,
                        division: division
                    };
                }
                
                collaborateurStats[nom].heures += heures;
                
                // Ne calculer le co√ªt que pour les heures HC
                if (row['Type Heure'] === 'HC') {
                    let cout = heures * taux;
                    collaborateurStats[nom].cout += cout;
                    collaborateurStats[nom].heuresHC += heures;
                } else {
                    collaborateurStats[nom].heuresHNC += heures;
                }
            });

            let totalCollaborateurs = Object.keys(collaborateurStats).length;
            let totalHeures = Object.values(collaborateurStats).reduce((sum, stats) => sum + stats.heures, 0);
            let heuresMoyennes = totalCollaborateurs > 0 ? totalHeures / totalCollaborateurs : 0;
            
            // Calculer le taux de chargeabilit√© global
            let totalHeuresHC = Object.values(collaborateurStats).reduce((sum, stats) => sum + stats.heuresHC, 0);
            let totalHeuresHNC = Object.values(collaborateurStats).reduce((sum, stats) => sum + stats.heuresHNC, 0);
            let tauxChargeabilite = (totalHeuresHC + totalHeuresHNC) > 0 ? (totalHeuresHC / (totalHeuresHC + totalHeuresHNC)) * 100 : 0;
            
            // Trouver le collaborateur le plus efficace (ratio HNC/HC le plus faible)
            let plusEfficace = Object.entries(collaborateurStats)
                .filter(([nom, stats]) => stats.heuresHC > 0 && (stats.heuresHC + stats.heuresHNC) > 0) // Seulement ceux avec des heures HC et total > 0
                .sort((a, b) => {
                    let ratioA = a[1].heuresHNC / a[1].heuresHC;
                    let ratioB = b[1].heuresHNC / b[1].heuresHC;
                    return ratioA - ratioB; // Plus le ratio est faible, meilleur
                })[0];
            let plusEfficaceName = plusEfficace ? plusEfficace[0] : 'N/A';

            return {
                totalCollaborateurs,
                heuresMoyennes,
                tauxChargeabilite,
                plusEfficace: plusEfficaceName
            };
        }





        function generatePerformanceTable() {
            let collaborateurStats = {};
            
            filteredData.forEach(row => {
                let nom = row['Nom'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                let grade = row['Grade'] || 'Non d√©fini';
                let division = row['Division'] || 'Non d√©fini';
                
                if (!collaborateurStats[nom]) {
                    collaborateurStats[nom] = {
                        heures: 0,
                        heuresHC: 0,
                        heuresHNC: 0,
                        grade: grade,
                        division: division
                    };
                }
                
                collaborateurStats[nom].heures += heures;
                
                if (row['Type Heure'] === 'HC') {
                    collaborateurStats[nom].heuresHC += heures;
                } else {
                    collaborateurStats[nom].heuresHNC += heures;
                }
            });

            // Calculer la productivit√© moyenne pour la comparaison
            let productivites = Object.values(collaborateurStats)
                .filter(stats => stats.heuresHC > 0)
                .map(stats => stats.heuresHNC / stats.heuresHC);
            let productiviteMoyenne = productivites.length > 0 ? 
                productivites.reduce((sum, val) => sum + val, 0) / productivites.length : 0;

            return Object.entries(collaborateurStats)
                .map(([nom, stats]) => {
                    let tauxChargeabilite = (stats.heuresHC + stats.heuresHNC) > 0 ? 
                        (stats.heuresHC / (stats.heuresHC + stats.heuresHNC)) * 100 : 0;
                    let ratioHCHNC = stats.heuresHC > 0 ? stats.heuresHNC / stats.heuresHC : 0;
                    let productiviteRelative = productiviteMoyenne > 0 ? 
                        ((productiviteMoyenne - ratioHCHNC) / productiviteMoyenne) * 100 : 0;
                    
                    // D√©terminer le statut
                    let statut = '';
                    let alertClass = '';
                    if (ratioHCHNC > 1.5) {
                        statut = '‚ö†Ô∏è Sous-performant';
                        alertClass = 'alert-low-performance';
                    } else if (ratioHCHNC < 0.5) {
                        statut = '‚úÖ Excellent';
                        alertClass = 'alert-excellent-performance';
                    } else if (ratioHCHNC < 1) {
                        statut = 'üëç Bon';
                        alertClass = 'alert-good-performance';
                    } else {
                        statut = '‚ö†Ô∏è √Ä am√©liorer';
                        alertClass = 'alert-medium-performance';
                    }
                    
                    return `
                        <tr class="${alertClass}">
                            <td>${nom}</td>
                            <td>${stats.grade}</td>
                            <td>${stats.division}</td>
                            <td>${stats.heures.toFixed(1)}h</td>
                            <td>${stats.heuresHC.toFixed(1)}h</td>
                            <td>${stats.heuresHNC.toFixed(1)}h</td>
                            <td>${tauxChargeabilite.toFixed(1)}%</td>
                            <td>${ratioHCHNC.toFixed(2)}</td>
                            <td>${ratioHCHNC.toFixed(2)}</td>
                            <td>${productiviteRelative.toFixed(1)}%</td>
                            <td>${statut}</td>
                        </tr>
                    `;
                })
                .sort((a, b) => {
                    // Trier par ratio HNC/HC croissant (meilleur en premier)
                    let ratioA = parseFloat(a.match(/td>([^<]+)<\/td>/g)[7].replace(/<\/?td>/g, ''));
                    let ratioB = parseFloat(b.match(/td>([^<]+)<\/td>/g)[7].replace(/<\/?td>/g, ''));
                    return ratioA - ratioB;
                })
                .join('');
        }

        function getTopCollaborateursProductivite() {
            let collaborateurStats = {};
            
            filteredData.forEach(row => {
                let nom = row['Nom'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                
                if (!collaborateurStats[nom]) {
                    collaborateurStats[nom] = { heuresHC: 0, heuresHNC: 0 };
                }
                
                if (row['Type Heure'] === 'HC') {
                    collaborateurStats[nom].heuresHC += heures;
                } else {
                    collaborateurStats[nom].heuresHNC += heures;
                }
            });

            let result = Object.entries(collaborateurStats)
                .filter(([nom, stats]) => stats.heuresHC > 0 && (stats.heuresHC + stats.heuresHNC) > 0) // Seulement ceux avec des heures HC et total > 0
                .map(([nom, stats]) => {
                    let ratio = stats.heuresHNC / stats.heuresHC;
                    return {
                        label: nom.length > 15 ? nom.substring(0, 15) + '...' : nom,
                        value: ratio
                    };
                })
                .sort((a, b) => a.value - b.value) // Plus le ratio est faible, meilleur
                .slice(0, 5);
            
            // Convertir en format attendu par renderChart
            let chartData = {};
            result.forEach(item => {
                chartData[item.label] = item.value;
            });
            
            return chartData;
        }

        function getPerformanceByDivision() {
            let divisionStats = {};
            
            filteredData.forEach(row => {
                let division = row['Division'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                
                if (!divisionStats[division]) {
                    divisionStats[division] = { heuresHC: 0, heuresHNC: 0 };
                }
                
                if (row['Type Heure'] === 'HC') {
                    divisionStats[division].heuresHC += heures;
                } else {
                    divisionStats[division].heuresHNC += heures;
                }
            });

            let result = Object.entries(divisionStats)
                .filter(([division, stats]) => (stats.heuresHC + stats.heuresHNC) > 0) // Seulement les divisions avec des heures
                .map(([division, stats]) => {
                    let totalHeures = stats.heuresHC + stats.heuresHNC;
                    let tauxChargeabilite = (stats.heuresHC / totalHeures) * 100;
                    return {
                        label: division,
                        value: tauxChargeabilite
                    };
                })
                .sort((a, b) => b.value - a.value);
            
            // Convertir en format attendu par renderChart
            let chartData = {};
            result.forEach(item => {
                chartData[item.label] = item.value;
            });
            
            return chartData;
        }

        function getRepartitionHCHNC() {
            let totalHeuresHC = 0;
            let totalHeuresHNC = 0;
            
            filteredData.forEach(row => {
                let heures = parseFloat(row['Heures']) || 0;
                
                if (row['Type Heure'] === 'HC') {
                    totalHeuresHC += heures;
                } else {
                    totalHeuresHNC += heures;
                }
            });

            return {
                'Heures Chargeables': totalHeuresHC,
                'Heures Non-Chargeables': totalHeuresHNC
            };
        }

        function getPerformanceByMonth() {
            let monthStats = {};
            
            filteredData.forEach(row => {
                let mois = row['Mois'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                
                if (!monthStats[mois]) {
                    monthStats[mois] = { heuresHC: 0, heuresHNC: 0 };
                }
                
                if (row['Type Heure'] === 'HC') {
                    monthStats[mois].heuresHC += heures;
                } else {
                    monthStats[mois].heuresHNC += heures;
                }
            });

            return Object.entries(monthStats)
                .sort((a, b) => a[0].localeCompare(b[0]))
                .reduce((obj, [mois, stats]) => {
                    let totalHeures = stats.heuresHC + stats.heuresHNC;
                    obj[mois] = totalHeures > 0 ? (stats.heuresHC / totalHeures) * 100 : 0;
                    return obj;
                }, {});
        }

        // ===== ONGLET OPPORTUNIT√âS =====
        // Focus : Pipeline commercial et opportunit√©s - Page autonome
        function renderOpportunitesTab() {
            if (!opportunitesData.length) {
                document.getElementById('tab-opportunites').innerHTML = '<div class="no-data">Aucune donn√©e d\'opportunit√©s disponible</div>';
                return;
            }

            let opportunitesStats = calculateOpportunitesStats();

            let opportunitesHTML = `
                <div class="kpi-cards">
                    <div class="kpi-card">
                        <span class="kpi-icon">üéØ</span>
                        <div class="kpi-label">Total Opportunit√©s</div>
                        <div class="kpi-value">${opportunitesStats.totalOpportunites}</div>
                    </div>
                    <div class="kpi-card">
                        <span class="kpi-icon">üí∞</span>
                        <div class="kpi-label">Valeur Totale</div>
                        <div class="kpi-value">${opportunitesStats.valeurTotale.toLocaleString()} XAF</div>
                    </div>
                    <div class="kpi-card">
                        <span class="kpi-icon">üìä</span>
                        <div class="kpi-label">Taux de Conversion</div>
                        <div class="kpi-value">${opportunitesStats.tauxConversion.toFixed(1)}%</div>
                    </div>
                    <div class="kpi-card">
                        <span class="kpi-icon">üìà</span>
                        <div class="kpi-label">Valeur Moyenne</div>
                        <div class="kpi-value">${opportunitesStats.valeurMoyenne.toLocaleString()} XAF</div>
                    </div>
                    <div class="kpi-card">
                        <span class="kpi-icon">üèÜ</span>
                        <div class="kpi-label">Opportunit√©s Gagn√©es</div>
                        <div class="kpi-value">${opportunitesStats.opportunitesGagnees}</div>
                    </div>
                    <div class="kpi-card">
                        <span class="kpi-icon">‚è≥</span>
                        <div class="kpi-label">En Cours</div>
                        <div class="kpi-value">${opportunitesStats.enCours}</div>
                    </div>
                </div>
                
                <!-- Filtres sp√©cifiques aux opportunit√©s -->
                <div class="filters-section" style="margin: 20px 0; padding: 15px; background: #f8f9fa; border-radius: 8px;">
                    <h3 style="margin-bottom: 15px; color: #333;">Filtres Opportunit√©s</h3>
                    <div class="filters-row">
                        <div class="filter-group">
                            <label for="opportuniteDivisionFilter">Division:</label>
                            <select id="opportuniteDivisionFilter">
                                <option value="">Toutes les divisions</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label for="opportuniteStatutFilter">Statut:</label>
                            <select id="opportuniteStatutFilter">
                                <option value="">Tous les statuts</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label for="opportuniteResponsableFilter">Responsable:</label>
                            <select id="opportuniteResponsableFilter">
                                <option value="">Tous les responsables</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label for="opportuniteSecteurFilter">Secteur:</label>
                            <select id="opportuniteSecteurFilter">
                                <option value="">Tous les secteurs</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label for="opportuniteTypeFilter">Type:</label>
                            <select id="opportuniteTypeFilter">
                                <option value="">Tous les types</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label for="opportuniteInitiativeFilter">Initiative:</label>
                            <select id="opportuniteInitiativeFilter">
                                <option value="">Toutes les initiatives</option>
                            </select>
                        </div>
                    </div>
                </div>
                
                <div class="charts-row">
                    <div class="chart-container">
                        <div class="section-title">Opportunit√©s par Division</div>
                        <canvas id="opportunitesChartDivision"></canvas>
                    </div>
                    <div class="chart-container">
                        <div class="section-title">R√©partition par Statut</div>
                        <canvas id="opportunitesChartStatut"></canvas>
                    </div>
                </div>
                <div class="charts-row">
                    <div class="chart-container">
                        <div class="section-title">Valeur par Secteur</div>
                        <canvas id="opportunitesChartSecteur"></canvas>
                    </div>
                    <div class="chart-container">
                        <div class="section-title">Top Responsables</div>
                        <canvas id="opportunitesChartResponsable"></canvas>
                    </div>
                </div>
                <div class="chart-container" style="margin-top: 20px;">
                    <div class="section-title">Pipeline Commercial</div>
                    <table id="opportunitesTable">
                        <thead>
                            <tr>
                                <th>Client</th>
                                <th>Opportunit√©</th>
                                <th>Division</th>
                                <th>Responsable</th>
                                <th>Valeur</th>
                                <th>Probabilit√©</th>
                                <th>Statut</th>
                                <th>Secteur</th>
                                <th>Type</th>
                                <th>Date Insertion</th>
                                <th>Derni√®re Action</th>
                                <th>Prochaine Action</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${generateOpportunitesTable()}
                        </tbody>
                    </table>
                </div>
            `;

            document.getElementById('tab-opportunites').innerHTML = opportunitesHTML;

            // Initialiser les filtres sp√©cifiques aux opportunit√©s
            setupOpportunitesFilters();
            
            // Appliquer les filtres initiaux
            applyOpportunitesFilters();

            // Rendu des graphiques
            renderChart('opportunitesChartDivision', getOpportunitesByDivision(), 'bar', 'Division', 'Valeur (XAF)');
            renderChart('opportunitesChartStatut', getOpportunitesByStatut(), 'doughnut', 'Statut', 'Nombre');
            renderChart('opportunitesChartSecteur', getOpportunitesBySecteur(), 'bar', 'Secteur', 'Valeur (XAF)');
            renderChart('opportunitesChartResponsable', getOpportunitesByResponsable(), 'bar', 'Responsable', 'Valeur (XAF)');
        }

        // ===== FONCTIONS FACTURATION =====
        function calculateFacturationStats() {
            let totalFactures = facturesData.length;
            let montantFacture = facturesData.reduce((sum, facture) => {
                let montant = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                return sum + montant;
            }, 0);
            let montantEncaisse = facturesData.reduce((sum, facture) => {
                let montant = parseFloat(facture['Montant Encaiss√©']?.replace(/\s/g, '') || '0');
                return sum + montant;
            }, 0);
            let tauxEncaissement = montantFacture > 0 ? (montantEncaisse / montantFacture) * 100 : 0;

            return {
                totalFactures,
                montantFacture,
                montantEncaisse,
                tauxEncaissement
            };
        }

        function getFacturationByDivision() {
            let divisionStats = {};
            facturesData.forEach(facture => {
                let division = facture['Division'] || 'Non d√©fini';
                let montant = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                
                if (!divisionStats[division]) {
                    divisionStats[division] = 0;
                }
                divisionStats[division] += montant;
            });

            return Object.entries(divisionStats)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10)
                .map(([division, montant]) => ({
                    label: division,
                    value: montant
                }));
        }

        function getFacturationByEtat() {
            let etatStats = {};
            facturesData.forEach(facture => {
                let montantFacture = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                let montantEncaisse = parseFloat(facture['Montant Encaiss√©']?.replace(/\s/g, '') || '0');
                let solde = montantFacture - montantEncaisse;
                let etat = solde === 0 ? 'Pay√©' : solde > 0 ? 'En attente' : 'Surpay√©';
                
                if (!etatStats[etat]) {
                    etatStats[etat] = 0;
                }
                etatStats[etat]++;
            });

            return Object.entries(etatStats).map(([etat, count]) => ({
                label: etat,
                value: count
            }));
        }

        function generateFacturationTable() {
            return facturesData.map(facture => {
                let montantFacture = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                let montantEncaisse = parseFloat(facture['Montant Encaiss√©']?.replace(/\s/g, '') || '0');
                let solde = montantFacture - montantEncaisse;
                let etat = solde === 0 ? 'Pay√©' : solde > 0 ? 'En attente' : 'Surpay√©';
                
                return `
                    <tr>
                        <td>${facture['Client'] || ''}</td>
                        <td>${facture['Mission'] || ''}</td>
                        <td>${facture['Division'] || ''}</td>
                        <td>${montantFacture.toLocaleString()} XAF</td>
                        <td>${montantEncaisse.toLocaleString()} XAF</td>
                        <td>${solde.toLocaleString()} XAF</td>
                        <td>${etat}</td>
                    </tr>
                `;
            }).join('');
        }

        // ===== FONCTIONS RENTABILIT√â =====
        function calculateRentabiliteStats() {
            // Calculer les co√ªts √† partir des donn√©es TRS filtr√©es
            let coutTotal = calculateTotalCost();
            
            // Calculer le CA √† partir des factures
            let caTotal = facturesData.reduce((sum, facture) => {
                let montant = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                return sum + montant;
            }, 0);
            
            let margeBrute = caTotal - coutTotal;
            let tauxMarge = caTotal > 0 ? (margeBrute / caTotal) * 100 : 0;
            
            // Nouveaux KPIs
            let roiGlobal = coutTotal > 0 ? (margeBrute / coutTotal) * 100 : 0;
            
            // Calculer le taux de rentabilit√© (missions rentables / total missions)
            let missionStats = {};
            filteredData.forEach(row => {
                let mission = row['Missions'] || 'Non d√©fini';
                if (!missionStats[mission]) {
                    missionStats[mission] = { cout: 0, ca: 0 };
                }
                if (row['Type Heure'] === 'HC') {
                    let heures = parseFloat(row['Heures']) || 0;
                    let taux = gradeToTaux[row['Grade']] || 0;
                    missionStats[mission].cout += heures * taux;
                }
            });
            
            facturesData.forEach(facture => {
                let mission = facture['Mission'] || 'Non d√©fini';
                let montant = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                if (!missionStats[mission]) {
                    missionStats[mission] = { cout: 0, ca: 0 };
                }
                missionStats[mission].ca += montant;
            });
            
            let missionsRentables = Object.values(missionStats).filter(stats => (stats.ca - stats.cout) > 0).length;
            let totalMissions = Object.keys(missionStats).length;
            let tauxRentabilite = totalMissions > 0 ? (missionsRentables / totalMissions) * 100 : 0;
            
            // CA moyen par mission
            let missionsFacturees = facturesData.length;
            let caMoyen = missionsFacturees > 0 ? caTotal / missionsFacturees : 0;

            return {
                caTotal,
                coutTotal,
                margeBrute,
                tauxMarge,
                roiGlobal,
                tauxRentabilite,
                caMoyen
            };
        }

        function getRentabiliteByMission() {
            let missionStats = {};
            
            // Calculer les co√ªts par mission (uniquement heures HC)
            filteredData.forEach(row => {
                let mission = row['Missions'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                let taux = gradeToTaux[row['Grade']] || 0;
                
                if (!missionStats[mission]) {
                    missionStats[mission] = { cout: 0, ca: 0 };
                }
                
                // Ne calculer le co√ªt que pour les heures HC
                if (row['Type Heure'] === 'HC') {
                    let cout = heures * taux;
                    missionStats[mission].cout += cout;
                }
            });
            
            // Ajouter les CA par mission depuis les factures
            facturesData.forEach(facture => {
                let mission = facture['Mission'] || 'Non d√©fini';
                let montant = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                
                if (!missionStats[mission]) {
                    missionStats[mission] = { cout: 0, ca: 0 };
                }
                missionStats[mission].ca += montant;
            });

            return Object.entries(missionStats)
                .map(([mission, stats]) => ({
                    label: mission,
                    value: stats.ca - stats.cout
                }))
                .sort((a, b) => b.value - a.value)
                .slice(0, 10);
        }

        function getRentabiliteByDivision() {
            let divisionStats = {};
            
            // Calculer les co√ªts par division (uniquement heures HC)
            filteredData.forEach(row => {
                let division = row['Division'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                let taux = gradeToTaux[row['Grade']] || 0;
                
                if (!divisionStats[division]) {
                    divisionStats[division] = { cout: 0, ca: 0 };
                }
                
                // Ne calculer le co√ªt que pour les heures HC
                if (row['Type Heure'] === 'HC') {
                    let cout = heures * taux;
                    divisionStats[division].cout += cout;
                }
            });
            
            // Ajouter les CA par division depuis les factures
            facturesData.forEach(facture => {
                let division = facture['Division'] || 'Non d√©fini';
                let montant = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                
                if (!divisionStats[division]) {
                    divisionStats[division] = { cout: 0, ca: 0 };
                }
                divisionStats[division].ca += montant;
            });

            return Object.entries(divisionStats)
                .map(([division, stats]) => ({
                    label: division,
                    value: stats.ca - stats.cout
                }))
                .sort((a, b) => b.value - a.value);
        }

        function getRentabiliteByMonth() {
            let monthStats = {};
            
            // Calculer les marges par mois
            filteredData.forEach(row => {
                let mois = row['Mois'] || 'Non d√©fini';
                let mission = row['Missions'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                let taux = gradeToTaux[row['Grade']] || 0;
                
                if (!monthStats[mois]) {
                    monthStats[mois] = { cout: 0, ca: 0 };
                }
                
                if (row['Type Heure'] === 'HC') {
                    let cout = heures * taux;
                    monthStats[mois].cout += cout;
                }
            });
            
            // Ajouter les CA par mois depuis les factures
            facturesData.forEach(facture => {
                let date = facture['Date'] || '';
                let mois = date.split('/')[1] || 'Non d√©fini'; // Extraire le mois de la date
                let montant = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                
                if (!monthStats[mois]) {
                    monthStats[mois] = { cout: 0, ca: 0 };
                }
                monthStats[mois].ca += montant;
            });
            
            return Object.entries(monthStats)
                .sort((a, b) => a[0].localeCompare(b[0]))
                .reduce((obj, [mois, stats]) => {
                    obj[mois] = stats.ca - stats.cout;
                    return obj;
                }, {});
        }

        function getRentabiliteByMarges() {
            let missionStats = {};
            
            // Calculer les marges par mission
            filteredData.forEach(row => {
                let mission = row['Missions'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                let taux = gradeToTaux[row['Grade']] || 0;
                
                if (!missionStats[mission]) {
                    missionStats[mission] = { cout: 0, ca: 0 };
                }
                
                if (row['Type Heure'] === 'HC') {
                    let cout = heures * taux;
                    missionStats[mission].cout += cout;
                }
            });
            
            facturesData.forEach(facture => {
                let mission = facture['Mission'] || 'Non d√©fini';
                let montant = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                
                if (!missionStats[mission]) {
                    missionStats[mission] = { cout: 0, ca: 0 };
                }
                missionStats[mission].ca += montant;
            });
            
            // Cat√©goriser les marges
            let margeCategories = {
                'D√©ficitaire (< 0)': 0,
                'Faible (0-50k)': 0,
                'Moyenne (50k-200k)': 0,
                '√âlev√©e (200k-500k)': 0,
                'Tr√®s √©lev√©e (> 500k)': 0
            };
            
            Object.values(missionStats).forEach(stats => {
                let marge = stats.ca - stats.cout;
                if (marge < 0) {
                    margeCategories['D√©ficitaire (< 0)']++;
                } else if (marge < 50000) {
                    margeCategories['Faible (0-50k)']++;
                } else if (marge < 200000) {
                    margeCategories['Moyenne (50k-200k)']++;
                } else if (marge < 500000) {
                    margeCategories['√âlev√©e (200k-500k)']++;
                } else {
                    margeCategories['Tr√®s √©lev√©e (> 500k)']++;
                }
            });
            
            return margeCategories;
        }

        function generateRentabiliteTable() {
            let missionStats = {};
            
            // Calculer les co√ªts par mission (uniquement heures HC)
            filteredData.forEach(row => {
                let mission = row['Missions'] || 'Non d√©fini';
                let division = row['Division'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                let taux = gradeToTaux[row['Grade']] || 0;
                
                if (!missionStats[mission]) {
                    missionStats[mission] = { 
                        division: division,
                        cout: 0, 
                        ca: 0,
                        heuresHC: 0
                    };
                }
                
                // Ne calculer le co√ªt que pour les heures HC
                if (row['Type Heure'] === 'HC') {
                    let cout = heures * taux;
                    missionStats[mission].cout += cout;
                    missionStats[mission].heuresHC += heures;
                }
            });
            
            // Ajouter les CA par mission depuis les factures
            facturesData.forEach(facture => {
                let mission = facture['Mission'] || 'Non d√©fini';
                let montant = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                
                if (!missionStats[mission]) {
                    missionStats[mission] = { 
                        division: facture['Division'] || 'Non d√©fini',
                        cout: 0, 
                        ca: 0,
                        heuresHC: 0
                    };
                }
                missionStats[mission].ca += montant;
            });

            return Object.entries(missionStats)
                .map(([mission, stats]) => {
                    let marge = stats.ca - stats.cout;
                    let tauxMarge = stats.ca > 0 ? (marge / stats.ca) * 100 : 0;
                    let roi = stats.cout > 0 ? (marge / stats.cout) * 100 : 0;
                    let coutParHeure = stats.heuresHC > 0 ? stats.cout / stats.heuresHC : 0;
                    let caParHeure = stats.heuresHC > 0 ? stats.ca / stats.heuresHC : 0;
                    let rentabilite = marge > 0 ? 'Rentable' : marge < 0 ? 'D√©ficitaire' : '√âquilibr√©';
                    
                    // Classes CSS pour les alertes
                    let alertClass = '';
                    if (marge < 0 || roi < 20) {
                        alertClass = 'alert-low-rentability';
                    }
                    
                    return `
                        <tr class="${alertClass}">
                            <td>${mission}</td>
                            <td>${stats.division}</td>
                            <td>${stats.heuresHC.toFixed(1)}h</td>
                            <td>${stats.cout.toLocaleString()} XAF</td>
                            <td>${stats.ca.toLocaleString()} XAF</td>
                            <td>${marge.toLocaleString()} XAF</td>
                            <td>${tauxMarge.toFixed(1)}%</td>
                            <td>${roi.toFixed(1)}%</td>
                            <td>${coutParHeure.toFixed(0)} XAF/h</td>
                            <td>${caParHeure.toFixed(0)} XAF/h</td>
                            <td>${rentabilite}</td>
                        </tr>
                    `;
                })
                .sort((a, b) => {
                    // Trier par rentabilit√© d√©croissante
                    let margeA = parseFloat(a.match(/td>([^<]+) XAF<\/td>/)[1].replace(/\s/g, ''));
                    let margeB = parseFloat(b.match(/td>([^<]+) XAF<\/td>/)[1].replace(/\s/g, ''));
                    return margeB - margeA;
                })
                .join('');
        }

        // ===== FONCTIONS PERFORMANCE =====
        function calculatePerformanceStats() {
            let collaborateurStats = {};
            
            filteredData.forEach(row => {
                let nom = row['Nom'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                let grade = row['Grade'] || 'Non d√©fini';
                let division = row['Division'] || 'Non d√©fini';
                let taux = gradeToTaux[grade] || 0;
                
                if (!collaborateurStats[nom]) {
                    collaborateurStats[nom] = {
                        heures: 0,
                        heuresHC: 0,
                        heuresHNC: 0,
                        cout: 0,
                        grade: grade,
                        division: division
                    };
                }
                
                collaborateurStats[nom].heures += heures;
                
                // Ne calculer le co√ªt que pour les heures HC
                if (row['Type Heure'] === 'HC') {
                    let cout = heures * taux;
                    collaborateurStats[nom].cout += cout;
                    collaborateurStats[nom].heuresHC += heures;
                } else {
                    collaborateurStats[nom].heuresHNC += heures;
                }
            });

            let totalCollaborateurs = Object.keys(collaborateurStats).length;
            let totalHeures = Object.values(collaborateurStats).reduce((sum, stats) => sum + stats.heures, 0);
            let heuresMoyennes = totalCollaborateurs > 0 ? totalHeures / totalCollaborateurs : 0;
            
            // Calculer le taux de chargeabilit√© global
            let totalHeuresHC = Object.values(collaborateurStats).reduce((sum, stats) => sum + stats.heuresHC, 0);
            let totalHeuresHNC = Object.values(collaborateurStats).reduce((sum, stats) => sum + stats.heuresHNC, 0);
            let tauxChargeabilite = (totalHeuresHC + totalHeuresHNC) > 0 ? (totalHeuresHC / (totalHeuresHC + totalHeuresHNC)) * 100 : 0;
            
            // Trouver le collaborateur le plus efficace (ratio HNC/HC le plus faible)
            let plusEfficace = Object.entries(collaborateurStats)
                .filter(([nom, stats]) => stats.heuresHC > 0 && (stats.heuresHC + stats.heuresHNC) > 0) // Seulement ceux avec des heures HC et total > 0
                .sort((a, b) => {
                    let ratioA = a[1].heuresHNC / a[1].heuresHC;
                    let ratioB = b[1].heuresHNC / b[1].heuresHC;
                    return ratioA - ratioB; // Plus le ratio est faible, meilleur
                })[0];
            let plusEfficaceName = plusEfficace ? plusEfficace[0] : 'N/A';

            return {
                totalCollaborateurs,
                heuresMoyennes,
                tauxChargeabilite,
                plusEfficace: plusEfficaceName
            };
        }





        function generatePerformanceTable() {
            let collaborateurStats = {};
            
            filteredData.forEach(row => {
                let nom = row['Nom'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                let grade = row['Grade'] || 'Non d√©fini';
                let division = row['Division'] || 'Non d√©fini';
                
                if (!collaborateurStats[nom]) {
                    collaborateurStats[nom] = {
                        heures: 0,
                        heuresHC: 0,
                        heuresHNC: 0,
                        grade: grade,
                        division: division
                    };
                }
                
                collaborateurStats[nom].heures += heures;
                
                if (row['Type Heure'] === 'HC') {
                    collaborateurStats[nom].heuresHC += heures;
                } else {
                    collaborateurStats[nom].heuresHNC += heures;
                }
            });

            // Calculer la productivit√© moyenne pour la comparaison
            let productivites = Object.values(collaborateurStats)
                .filter(stats => stats.heuresHC > 0)
                .map(stats => stats.heuresHNC / stats.heuresHC);
            let productiviteMoyenne = productivites.length > 0 ? 
                productivites.reduce((sum, val) => sum + val, 0) / productivites.length : 0;

            return Object.entries(collaborateurStats)
                .map(([nom, stats]) => {
                    let tauxChargeabilite = (stats.heuresHC + stats.heuresHNC) > 0 ? 
                        (stats.heuresHC / (stats.heuresHC + stats.heuresHNC)) * 100 : 0;
                    let ratioHCHNC = stats.heuresHC > 0 ? stats.heuresHNC / stats.heuresHC : 0;
                    let productiviteRelative = productiviteMoyenne > 0 ? 
                        ((productiviteMoyenne - ratioHCHNC) / productiviteMoyenne) * 100 : 0;
                    
                    // D√©terminer le statut
                    let statut = '';
                    let alertClass = '';
                    if (ratioHCHNC > 1.5) {
                        statut = '‚ö†Ô∏è Sous-performant';
                        alertClass = 'alert-low-performance';
                    } else if (ratioHCHNC < 0.5) {
                        statut = '‚úÖ Excellent';
                        alertClass = 'alert-excellent-performance';
                    } else if (ratioHCHNC < 1) {
                        statut = 'üëç Bon';
                        alertClass = 'alert-good-performance';
                    } else {
                        statut = '‚ö†Ô∏è √Ä am√©liorer';
                        alertClass = 'alert-medium-performance';
                    }
                    
                    return `
                        <tr class="${alertClass}">
                            <td>${nom}</td>
                            <td>${stats.grade}</td>
                            <td>${stats.division}</td>
                            <td>${stats.heures.toFixed(1)}h</td>
                            <td>${stats.heuresHC.toFixed(1)}h</td>
                            <td>${stats.heuresHNC.toFixed(1)}h</td>
                            <td>${tauxChargeabilite.toFixed(1)}%</td>
                            <td>${ratioHCHNC.toFixed(2)}</td>
                            <td>${ratioHCHNC.toFixed(2)}</td>
                            <td>${productiviteRelative.toFixed(1)}%</td>
                            <td>${statut}</td>
                        </tr>
                    `;
                })
                .sort((a, b) => {
                    // Trier par ratio HNC/HC croissant (meilleur en premier)
                    let ratioA = parseFloat(a.match(/td>([^<]+)<\/td>/g)[7].replace(/<\/?td>/g, ''));
                    let ratioB = parseFloat(b.match(/td>([^<]+)<\/td>/g)[7].replace(/<\/?td>/g, ''));
                    return ratioA - ratioB;
                })
                .join('');
        }

        function getTopCollaborateursProductivite() {
            let collaborateurStats = {};
            
            filteredData.forEach(row => {
                let nom = row['Nom'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                
                if (!collaborateurStats[nom]) {
                    collaborateurStats[nom] = { heuresHC: 0, heuresHNC: 0 };
                }
                
                if (row['Type Heure'] === 'HC') {
                    collaborateurStats[nom].heuresHC += heures;
                } else {
                    collaborateurStats[nom].heuresHNC += heures;
                }
            });

            let result = Object.entries(collaborateurStats)
                .filter(([nom, stats]) => stats.heuresHC > 0 && (stats.heuresHC + stats.heuresHNC) > 0) // Seulement ceux avec des heures HC et total > 0
                .map(([nom, stats]) => {
                    let ratio = stats.heuresHNC / stats.heuresHC;
                    return {
                        label: nom.length > 15 ? nom.substring(0, 15) + '...' : nom,
                        value: ratio
                    };
                })
                .sort((a, b) => a.value - b.value) // Plus le ratio est faible, meilleur
                .slice(0, 5);
            
            // Convertir en format attendu par renderChart
            let chartData = {};
            result.forEach(item => {
                chartData[item.label] = item.value;
            });
            
            return chartData;
        }

        function getPerformanceByDivision() {
            let divisionStats = {};
            
            filteredData.forEach(row => {
                let division = row['Division'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                
                if (!divisionStats[division]) {
                    divisionStats[division] = { heuresHC: 0, heuresHNC: 0 };
                }
                
                if (row['Type Heure'] === 'HC') {
                    divisionStats[division].heuresHC += heures;
                } else {
                    divisionStats[division].heuresHNC += heures;
                }
            });

            let result = Object.entries(divisionStats)
                .filter(([division, stats]) => (stats.heuresHC + stats.heuresHNC) > 0) // Seulement les divisions avec des heures
                .map(([division, stats]) => {
                    let totalHeures = stats.heuresHC + stats.heuresHNC;
                    let tauxChargeabilite = (stats.heuresHC / totalHeures) * 100;
                    return {
                        label: division,
                        value: tauxChargeabilite
                    };
                })
                .sort((a, b) => b.value - a.value);
            
            // Convertir en format attendu par renderChart
            let chartData = {};
            result.forEach(item => {
                chartData[item.label] = item.value;
            });
            
            return chartData;
        }

        function getRepartitionHCHNC() {
            let totalHeuresHC = 0;
            let totalHeuresHNC = 0;
            
            filteredData.forEach(row => {
                let heures = parseFloat(row['Heures']) || 0;
                
                if (row['Type Heure'] === 'HC') {
                    totalHeuresHC += heures;
                } else {
                    totalHeuresHNC += heures;
                }
            });

            return {
                'Heures Chargeables': totalHeuresHC,
                'Heures Non-Chargeables': totalHeuresHNC
            };
        }

        function getPerformanceByMonth() {
            let monthStats = {};
            
            filteredData.forEach(row => {
                let mois = row['Mois'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                
                if (!monthStats[mois]) {
                    monthStats[mois] = { heuresHC: 0, heuresHNC: 0 };
                }
                
                if (row['Type Heure'] === 'HC') {
                    monthStats[mois].heuresHC += heures;
                } else {
                    monthStats[mois].heuresHNC += heures;
                }
            });

            return Object.entries(monthStats)
                .sort((a, b) => a[0].localeCompare(b[0]))
                .reduce((obj, [mois, stats]) => {
                    let totalHeures = stats.heuresHC + stats.heuresHNC;
                    obj[mois] = totalHeures > 0 ? (stats.heuresHC / totalHeures) * 100 : 0;
                    return obj;
                }, {});
        }

        // ===== ONGLET OPPORTUNIT√âS =====
        // Focus : Pipeline commercial et opportunit√©s - Page autonome
        function renderOpportunitesTab() {
            if (!opportunitesData.length) {
                document.getElementById('tab-opportunites').innerHTML = '<div class="no-data">Aucune donn√©e d\'opportunit√©s disponible</div>';
                return;
            }

            let opportunitesStats = calculateOpportunitesStats();

            let opportunitesHTML = `
                <div class="kpi-cards">
                    <div class="kpi-card">
                        <span class="kpi-icon">üéØ</span>
                        <div class="kpi-label">Total Opportunit√©s</div>
                        <div class="kpi-value">${opportunitesStats.totalOpportunites}</div>
                    </div>
                    <div class="kpi-card">
                        <span class="kpi-icon">üí∞</span>
                        <div class="kpi-label">Valeur Totale</div>
                        <div class="kpi-value">${opportunitesStats.valeurTotale.toLocaleString()} XAF</div>
                    </div>
                    <div class="kpi-card">
                        <span class="kpi-icon">üìä</span>
                        <div class="kpi-label">Taux de Conversion</div>
                        <div class="kpi-value">${opportunitesStats.tauxConversion.toFixed(1)}%</div>
                    </div>
                    <div class="kpi-card">
                        <span class="kpi-icon">üìà</span>
                        <div class="kpi-label">Valeur Moyenne</div>
                        <div class="kpi-value">${opportunitesStats.valeurMoyenne.toLocaleString()} XAF</div>
                    </div>
                    <div class="kpi-card">
                        <span class="kpi-icon">üèÜ</span>
                        <div class="kpi-label">Opportunit√©s Gagn√©es</div>
                        <div class="kpi-value">${opportunitesStats.opportunitesGagnees}</div>
                    </div>
                    <div class="kpi-card">
                        <span class="kpi-icon">‚è≥</span>
                        <div class="kpi-label">En Cours</div>
                        <div class="kpi-value">${opportunitesStats.enCours}</div>
                    </div>
                </div>
                
                <!-- Filtres sp√©cifiques aux opportunit√©s -->
                <div class="filters-section" style="margin: 20px 0; padding: 15px; background: #f8f9fa; border-radius: 8px;">
                    <h3 style="margin-bottom: 15px; color: #333;">Filtres Opportunit√©s</h3>
                    <div class="filters-row">
                        <div class="filter-group">
                            <label for="opportuniteDivisionFilter">Division:</label>
                            <select id="opportuniteDivisionFilter">
                                <option value="">Toutes les divisions</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label for="opportuniteStatutFilter">Statut:</label>
                            <select id="opportuniteStatutFilter">
                                <option value="">Tous les statuts</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label for="opportuniteResponsableFilter">Responsable:</label>
                            <select id="opportuniteResponsableFilter">
                                <option value="">Tous les responsables</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label for="opportuniteSecteurFilter">Secteur:</label>
                            <select id="opportuniteSecteurFilter">
                                <option value="">Tous les secteurs</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label for="opportuniteTypeFilter">Type:</label>
                            <select id="opportuniteTypeFilter">
                                <option value="">Tous les types</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label for="opportuniteInitiativeFilter">Initiative:</label>
                            <select id="opportuniteInitiativeFilter">
                                <option value="">Toutes les initiatives</option>
                            </select>
                        </div>
                    </div>
                </div>
                
                <div class="charts-row">
                    <div class="chart-container">
                        <div class="section-title">Opportunit√©s par Division</div>
                        <canvas id="opportunitesChartDivision"></canvas>
                    </div>
                    <div class="chart-container">
                        <div class="section-title">R√©partition par Statut</div>
                        <canvas id="opportunitesChartStatut"></canvas>
                    </div>
                </div>
                <div class="charts-row">
                    <div class="chart-container">
                        <div class="section-title">Valeur par Secteur</div>
                        <canvas id="opportunitesChartSecteur"></canvas>
                    </div>
                    <div class="chart-container">
                        <div class="section-title">Top Responsables</div>
                        <canvas id="opportunitesChartResponsable"></canvas>
                    </div>
                </div>
                <div class="chart-container" style="margin-top: 20px;">
                    <div class="section-title">Pipeline Commercial</div>
                    <table id="opportunitesTable">
                        <thead>
                            <tr>
                                <th>Client</th>
                                <th>Opportunit√©</th>
                                <th>Division</th>
                                <th>Responsable</th>
                                <th>Valeur</th>
                                <th>Probabilit√©</th>
                                <th>Statut</th>
                                <th>Secteur</th>
                                <th>Type</th>
                                <th>Date Insertion</th>
                                <th>Derni√®re Action</th>
                                <th>Prochaine Action</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${generateOpportunitesTable()}
                        </tbody>
                    </table>
                </div>
            `;

            document.getElementById('tab-opportunites').innerHTML = opportunitesHTML;

            // Initialiser les filtres sp√©cifiques aux opportunit√©s
            setupOpportunitesFilters();
            
            // Appliquer les filtres initiaux
            applyOpportunitesFilters();

            // Rendu des graphiques
            renderChart('opportunitesChartDivision', getOpportunitesByDivision(), 'bar', 'Division', 'Valeur (XAF)');
            renderChart('opportunitesChartStatut', getOpportunitesByStatut(), 'doughnut', 'Statut', 'Nombre');
            renderChart('opportunitesChartSecteur', getOpportunitesBySecteur(), 'bar', 'Secteur', 'Valeur (XAF)');
            renderChart('opportunitesChartResponsable', getOpportunitesByResponsable(), 'bar', 'Responsable', 'Valeur (XAF)');
        }

        // ===== FONCTIONS FACTURATION =====
        function calculateFacturationStats() {
            let totalFactures = facturesData.length;
            let montantFacture = facturesData.reduce((sum, facture) => {
                let montant = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                return sum + montant;
            }, 0);
            let montantEncaisse = facturesData.reduce((sum, facture) => {
                let montant = parseFloat(facture['Montant Encaiss√©']?.replace(/\s/g, '') || '0');
                return sum + montant;
            }, 0);
            let tauxEncaissement = montantFacture > 0 ? (montantEncaisse / montantFacture) * 100 : 0;

            return {
                totalFactures,
                montantFacture,
                montantEncaisse,
                tauxEncaissement
            };
        }

        function getFacturationByDivision() {
            let divisionStats = {};
            facturesData.forEach(facture => {
                let division = facture['Division'] || 'Non d√©fini';
                let montant = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                
                if (!divisionStats[division]) {
                    divisionStats[division] = 0;
                }
                divisionStats[division] += montant;
            });

            return Object.entries(divisionStats)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10)
                .map(([division, montant]) => ({
                    label: division,
                    value: montant
                }));
        }

        function getFacturationByEtat() {
            let etatStats = {};
            facturesData.forEach(facture => {
                let montantFacture = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                let montantEncaisse = parseFloat(facture['Montant Encaiss√©']?.replace(/\s/g, '') || '0');
                let solde = montantFacture - montantEncaisse;
                let etat = solde === 0 ? 'Pay√©' : solde > 0 ? 'En attente' : 'Surpay√©';
                
                if (!etatStats[etat]) {
                    etatStats[etat] = 0;
                }
                etatStats[etat]++;
            });

            return Object.entries(etatStats).map(([etat, count]) => ({
                label: etat,
                value: count
            }));
        }

        function generateFacturationTable() {
            return facturesData.map(facture => {
                let montantFacture = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                let montantEncaisse = parseFloat(facture['Montant Encaiss√©']?.replace(/\s/g, '') || '0');
                let solde = montantFacture - montantEncaisse;
                let etat = solde === 0 ? 'Pay√©' : solde > 0 ? 'En attente' : 'Surpay√©';
                
                return `
                    <tr>
                        <td>${facture['Client'] || ''}</td>
                        <td>${facture['Mission'] || ''}</td>
                        <td>${facture['Division'] || ''}</td>
                        <td>${montantFacture.toLocaleString()} XAF</td>
                        <td>${montantEncaisse.toLocaleString()} XAF</td>
                        <td>${solde.toLocaleString()} XAF</td>
                        <td>${etat}</td>
                    </tr>
                `;
            }).join('');
        }

        // ===== FONCTIONS RENTABILIT√â =====
        function calculateRentabiliteStats() {
            // Calculer les co√ªts √† partir des donn√©es TRS filtr√©es
            let coutTotal = calculateTotalCost();
            
            // Calculer le CA √† partir des factures
            let caTotal = facturesData.reduce((sum, facture) => {
                let montant = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                return sum + montant;
            }, 0);
            
            let margeBrute = caTotal - coutTotal;
            let tauxMarge = caTotal > 0 ? (margeBrute / caTotal) * 100 : 0;
            
            // Nouveaux KPIs
            let roiGlobal = coutTotal > 0 ? (margeBrute / coutTotal) * 100 : 0;
            
            // Calculer le taux de rentabilit√© (missions rentables / total missions)
            let missionStats = {};
            filteredData.forEach(row => {
                let mission = row['Missions'] || 'Non d√©fini';
                if (!missionStats[mission]) {
                    missionStats[mission] = { cout: 0, ca: 0 };
                }
                if (row['Type Heure'] === 'HC') {
                    let heures = parseFloat(row['Heures']) || 0;
                    let taux = gradeToTaux[row['Grade']] || 0;
                    missionStats[mission].cout += heures * taux;
                }
            });
            
            facturesData.forEach(facture => {
                let mission = facture['Mission'] || 'Non d√©fini';
                let montant = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                if (!missionStats[mission]) {
                    missionStats[mission] = { cout: 0, ca: 0 };
                }
                missionStats[mission].ca += montant;
            });
            
            let missionsRentables = Object.values(missionStats).filter(stats => (stats.ca - stats.cout) > 0).length;
            let totalMissions = Object.keys(missionStats).length;
            let tauxRentabilite = totalMissions > 0 ? (missionsRentables / totalMissions) * 100 : 0;
            
            // CA moyen par mission
            let missionsFacturees = facturesData.length;
            let caMoyen = missionsFacturees > 0 ? caTotal / missionsFacturees : 0;

            return {
                caTotal,
                coutTotal,
                margeBrute,
                tauxMarge,
                roiGlobal,
                tauxRentabilite,
                caMoyen
            };
        }

        function getRentabiliteByMission() {
            let missionStats = {};
            
            // Calculer les co√ªts par mission (uniquement heures HC)
            filteredData.forEach(row => {
                let mission = row['Missions'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                let taux = gradeToTaux[row['Grade']] || 0;
                
                if (!missionStats[mission]) {
                    missionStats[mission] = { cout: 0, ca: 0 };
                }
                
                // Ne calculer le co√ªt que pour les heures HC
                if (row['Type Heure'] === 'HC') {
                    let cout = heures * taux;
                    missionStats[mission].cout += cout;
                }
            });
            
            // Ajouter les CA par mission depuis les factures
            facturesData.forEach(facture => {
                let mission = facture['Mission'] || 'Non d√©fini';
                let montant = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                
                if (!missionStats[mission]) {
                    missionStats[mission] = { cout: 0, ca: 0 };
                }
                missionStats[mission].ca += montant;
            });

            return Object.entries(missionStats)
                .map(([mission, stats]) => ({
                    label: mission,
                    value: stats.ca - stats.cout
                }))
                .sort((a, b) => b.value - a.value)
                .slice(0, 10);
        }

        function getRentabiliteByDivision() {
            let divisionStats = {};
            
            // Calculer les co√ªts par division (uniquement heures HC)
            filteredData.forEach(row => {
                let division = row['Division'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                let taux = gradeToTaux[row['Grade']] || 0;
                
                if (!divisionStats[division]) {
                    divisionStats[division] = { cout: 0, ca: 0 };
                }
                
                // Ne calculer le co√ªt que pour les heures HC
                if (row['Type Heure'] === 'HC') {
                    let cout = heures * taux;
                    divisionStats[division].cout += cout;
                }
            });
            
            // Ajouter les CA par division depuis les factures
            facturesData.forEach(facture => {
                let division = facture['Division'] || 'Non d√©fini';
                let montant = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                
                if (!divisionStats[division]) {
                    divisionStats[division] = { cout: 0, ca: 0 };
                }
                divisionStats[division].ca += montant;
            });

            return Object.entries(divisionStats)
                .map(([division, stats]) => ({
                    label: division,
                    value: stats.ca - stats.cout
                }))
                .sort((a, b) => b.value - a.value);
        }

        function getRentabiliteByMonth() {
            let monthStats = {};
            
            // Calculer les marges par mois
            filteredData.forEach(row => {
                let mois = row['Mois'] || 'Non d√©fini';
                let mission = row['Missions'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                let taux = gradeToTaux[row['Grade']] || 0;
                
                if (!monthStats[mois]) {
                    monthStats[mois] = { cout: 0, ca: 0 };
                }
                
                if (row['Type Heure'] === 'HC') {
                    let cout = heures * taux;
                    monthStats[mois].cout += cout;
                }
            });
            
            // Ajouter les CA par mois depuis les factures
            facturesData.forEach(facture => {
                let date = facture['Date'] || '';
                let mois = date.split('/')[1] || 'Non d√©fini'; // Extraire le mois de la date
                let montant = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                
                if (!monthStats[mois]) {
                    monthStats[mois] = { cout: 0, ca: 0 };
                }
                monthStats[mois].ca += montant;
            });
            
            return Object.entries(monthStats)
                .sort((a, b) => a[0].localeCompare(b[0]))
                .reduce((obj, [mois, stats]) => {
                    obj[mois] = stats.ca - stats.cout;
                    return obj;
                }, {});
        }

        function getRentabiliteByMarges() {
            let missionStats = {};
            
            // Calculer les marges par mission
            filteredData.forEach(row => {
                let mission = row['Missions'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                let taux = gradeToTaux[row['Grade']] || 0;
                
                if (!missionStats[mission]) {
                    missionStats[mission] = { cout: 0, ca: 0 };
                }
                
                if (row['Type Heure'] === 'HC') {
                    let cout = heures * taux;
                    missionStats[mission].cout += cout;
                }
            });
            
            facturesData.forEach(facture => {
                let mission = facture['Mission'] || 'Non d√©fini';
                let montant = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                
                if (!missionStats[mission]) {
                    missionStats[mission] = { cout: 0, ca: 0 };
                }
                missionStats[mission].ca += montant;
            });
            
            // Cat√©goriser les marges
            let margeCategories = {
                'D√©ficitaire (< 0)': 0,
                'Faible (0-50k)': 0,
                'Moyenne (50k-200k)': 0,
                '√âlev√©e (200k-500k)': 0,
                'Tr√®s √©lev√©e (> 500k)': 0
            };
            
            Object.values(missionStats).forEach(stats => {
                let marge = stats.ca - stats.cout;
                if (marge < 0) {
                    margeCategories['D√©ficitaire (< 0)']++;
                } else if (marge < 50000) {
                    margeCategories['Faible (0-50k)']++;
                } else if (marge < 200000) {
                    margeCategories['Moyenne (50k-200k)']++;
                } else if (marge < 500000) {
                    margeCategories['√âlev√©e (200k-500k)']++;
                } else {
                    margeCategories['Tr√®s √©lev√©e (> 500k)']++;
                }
            });
            
            return margeCategories;
        }

        function generateRentabiliteTable() {
            let missionStats = {};
            
            // Calculer les co√ªts par mission (uniquement heures HC)
            filteredData.forEach(row => {
                let mission = row['Missions'] || 'Non d√©fini';
                let division = row['Division'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                let taux = gradeToTaux[row['Grade']] || 0;
                
                if (!missionStats[mission]) {
                    missionStats[mission] = { 
                        division: division,
                        cout: 0, 
                        ca: 0,
                        heuresHC: 0
                    };
                }
                
                // Ne calculer le co√ªt que pour les heures HC
                if (row['Type Heure'] === 'HC') {
                    let cout = heures * taux;
                    missionStats[mission].cout += cout;
                    missionStats[mission].heuresHC += heures;
                }
            });
            
            // Ajouter les CA par mission depuis les factures
            facturesData.forEach(facture => {
                let mission = facture['Mission'] || 'Non d√©fini';
                let montant = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                
                if (!missionStats[mission]) {
                    missionStats[mission] = { 
                        division: facture['Division'] || 'Non d√©fini',
                        cout: 0, 
                        ca: 0,
                        heuresHC: 0
                    };
                }
                missionStats[mission].ca += montant;
            });

            return Object.entries(missionStats)
                .map(([mission, stats]) => {
                    let marge = stats.ca - stats.cout;
                    let tauxMarge = stats.ca > 0 ? (marge / stats.ca) * 100 : 0;
                    let roi = stats.cout > 0 ? (marge / stats.cout) * 100 : 0;
                    let coutParHeure = stats.heuresHC > 0 ? stats.cout / stats.heuresHC : 0;
                    let caParHeure = stats.heuresHC > 0 ? stats.ca / stats.heuresHC : 0;
                    let rentabilite = marge > 0 ? 'Rentable' : marge < 0 ? 'D√©ficitaire' : '√âquilibr√©';
                    
                    // Classes CSS pour les alertes
                    let alertClass = '';
                    if (marge < 0 || roi < 20) {
                        alertClass = 'alert-low-rentability';
                    }
                    
                    return `
                        <tr class="${alertClass}">
                            <td>${mission}</td>
                            <td>${stats.division}</td>
                            <td>${stats.heuresHC.toFixed(1)}h</td>
                            <td>${stats.cout.toLocaleString()} XAF</td>
                            <td>${stats.ca.toLocaleString()} XAF</td>
                            <td>${marge.toLocaleString()} XAF</td>
                            <td>${tauxMarge.toFixed(1)}%</td>
                            <td>${roi.toFixed(1)}%</td>
                            <td>${coutParHeure.toFixed(0)} XAF/h</td>
                            <td>${caParHeure.toFixed(0)} XAF/h</td>
                            <td>${rentabilite}</td>
                        </tr>
                    `;
                })
                .sort((a, b) => {
                    // Trier par rentabilit√© d√©croissante
                    let margeA = parseFloat(a.match(/td>([^<]+) XAF<\/td>/)[1].replace(/\s/g, ''));
                    let margeB = parseFloat(b.match(/td>([^<]+) XAF<\/td>/)[1].replace(/\s/g, ''));
                    return margeB - margeA;
                })
                .join('');
        }

        // ===== FONCTIONS PERFORMANCE =====
        function calculatePerformanceStats() {
            let collaborateurStats = {};
            
            filteredData.forEach(row => {
                let nom = row['Nom'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                let grade = row['Grade'] || 'Non d√©fini';
                let division = row['Division'] || 'Non d√©fini';
                let taux = gradeToTaux[grade] || 0;
                
                if (!collaborateurStats[nom]) {
                    collaborateurStats[nom] = {
                        heures: 0,
                        heuresHC: 0,
                        heuresHNC: 0,
                        cout: 0,
                        grade: grade,
                        division: division
                    };
                }
                
                collaborateurStats[nom].heures += heures;
                
                // Ne calculer le co√ªt que pour les heures HC
                if (row['Type Heure'] === 'HC') {
                    let cout = heures * taux;
                    collaborateurStats[nom].cout += cout;
                    collaborateurStats[nom].heuresHC += heures;
                } else {
                    collaborateurStats[nom].heuresHNC += heures;
                }
            });

            let totalCollaborateurs = Object.keys(collaborateurStats).length;
            let totalHeures = Object.values(collaborateurStats).reduce((sum, stats) => sum + stats.heures, 0);
            let heuresMoyennes = totalCollaborateurs > 0 ? totalHeures / totalCollaborateurs : 0;
            
            // Calculer le taux de chargeabilit√© global
            let totalHeuresHC = Object.values(collaborateurStats).reduce((sum, stats) => sum + stats.heuresHC, 0);
            let totalHeuresHNC = Object.values(collaborateurStats).reduce((sum, stats) => sum + stats.heuresHNC, 0);
            let tauxChargeabilite = (totalHeuresHC + totalHeuresHNC) > 0 ? (totalHeuresHC / (totalHeuresHC + totalHeuresHNC)) * 100 : 0;
            
            // Trouver le collaborateur le plus efficace (ratio HNC/HC le plus faible)
            let plusEfficace = Object.entries(collaborateurStats)
                .filter(([nom, stats]) => stats.heuresHC > 0 && (stats.heuresHC + stats.heuresHNC) > 0) // Seulement ceux avec des heures HC et total > 0
                .sort((a, b) => {
                    let ratioA = a[1].heuresHNC / a[1].heuresHC;
                    let ratioB = b[1].heuresHNC / b[1].heuresHC;
                    return ratioA - ratioB; // Plus le ratio est faible, meilleur
                })[0];
            let plusEfficaceName = plusEfficace ? plusEfficace[0] : 'N/A';

            return {
                totalCollaborateurs,
                heuresMoyennes,
                tauxChargeabilite,
                plusEfficace: plusEfficaceName
            };
        }





        function generatePerformanceTable() {
            let collaborateurStats = {};
            
            filteredData.forEach(row => {
                let nom = row['Nom'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                let grade = row['Grade'] || 'Non d√©fini';
                let division = row['Division'] || 'Non d√©fini';
                
                if (!collaborateurStats[nom]) {
                    collaborateurStats[nom] = {
                        heures: 0,
                        heuresHC: 0,
                        heuresHNC: 0,
                        grade: grade,
                        division: division
                    };
                }
                
                collaborateurStats[nom].heures += heures;
                
                if (row['Type Heure'] === 'HC') {
                    collaborateurStats[nom].heuresHC += heures;
                } else {
                    collaborateurStats[nom].heuresHNC += heures;
                }
            });

            // Calculer la productivit√© moyenne pour la comparaison
            let productivites = Object.values(collaborateurStats)
                .filter(stats => stats.heuresHC > 0)
                .map(stats => stats.heuresHNC / stats.heuresHC);
            let productiviteMoyenne = productivites.length > 0 ? 
                productivites.reduce((sum, val) => sum + val, 0) / productivites.length : 0;

            return Object.entries(collaborateurStats)
                .map(([nom, stats]) => {
                    let tauxChargeabilite = (stats.heuresHC + stats.heuresHNC) > 0 ? 
                        (stats.heuresHC / (stats.heuresHC + stats.heuresHNC)) * 100 : 0;
                    let ratioHCHNC = stats.heuresHC > 0 ? stats.heuresHNC / stats.heuresHC : 0;
                    let productiviteRelative = productiviteMoyenne > 0 ? 
                        ((productiviteMoyenne - ratioHCHNC) / productiviteMoyenne) * 100 : 0;
                    
                    // D√©terminer le statut
                    let statut = '';
                    let alertClass = '';
                    if (ratioHCHNC > 1.5) {
                        statut = '‚ö†Ô∏è Sous-performant';
                        alertClass = 'alert-low-performance';
                    } else if (ratioHCHNC < 0.5) {
                        statut = '‚úÖ Excellent';
                        alertClass = 'alert-excellent-performance';
                    } else if (ratioHCHNC < 1) {
                        statut = 'üëç Bon';
                        alertClass = 'alert-good-performance';
                    } else {
                        statut = '‚ö†Ô∏è √Ä am√©liorer';
                        alertClass = 'alert-medium-performance';
                    }
                    
                    return `
                        <tr class="${alertClass}">
                            <td>${nom}</td>
                            <td>${stats.grade}</td>
                            <td>${stats.division}</td>
                            <td>${stats.heures.toFixed(1)}h</td>
                            <td>${stats.heuresHC.toFixed(1)}h</td>
                            <td>${stats.heuresHNC.toFixed(1)}h</td>
                            <td>${tauxChargeabilite.toFixed(1)}%</td>
                            <td>${ratioHCHNC.toFixed(2)}</td>
                            <td>${ratioHCHNC.toFixed(2)}</td>
                            <td>${productiviteRelative.toFixed(1)}%</td>
                            <td>${statut}</td>
                        </tr>
                    `;
                })
                .sort((a, b) => {
                    // Trier par ratio HNC/HC croissant (meilleur en premier)
                    let ratioA = parseFloat(a.match(/td>([^<]+)<\/td>/g)[7].replace(/<\/?td>/g, ''));
                    let ratioB = parseFloat(b.match(/td>([^<]+)<\/td>/g)[7].replace(/<\/?td>/g, ''));
                    return ratioA - ratioB;
                })
                .join('');
        }

        function getTopCollaborateursProductivite() {
            let collaborateurStats = {};
            
            filteredData.forEach(row => {
                let nom = row['Nom'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                
                if (!collaborateurStats[nom]) {
                    collaborateurStats[nom] = { heuresHC: 0, heuresHNC: 0 };
                }
                
                if (row['Type Heure'] === 'HC') {
                    collaborateurStats[nom].heuresHC += heures;
                } else {
                    collaborateurStats[nom].heuresHNC += heures;
                }
            });

            let result = Object.entries(collaborateurStats)
                .filter(([nom, stats]) => stats.heuresHC > 0 && (stats.heuresHC + stats.heuresHNC) > 0) // Seulement ceux avec des heures HC et total > 0
                .map(([nom, stats]) => {
                    let ratio = stats.heuresHNC / stats.heuresHC;
                    return {
                        label: nom.length > 15 ? nom.substring(0, 15) + '...' : nom,
                        value: ratio
                    };
                })
                .sort((a, b) => a.value - b.value) // Plus le ratio est faible, meilleur
                .slice(0, 5);
            
            // Convertir en format attendu par renderChart
            let chartData = {};
            result.forEach(item => {
                chartData[item.label] = item.value;
            });
            
            return chartData;
        }

        function getPerformanceByDivision() {
            let divisionStats = {};
            
            filteredData.forEach(row => {
                let division = row['Division'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                
                if (!divisionStats[division]) {
                    divisionStats[division] = { heuresHC: 0, heuresHNC: 0 };
                }
                
                if (row['Type Heure'] === 'HC') {
                    divisionStats[division].heuresHC += heures;
                } else {
                    divisionStats[division].heuresHNC += heures;
                }
            });

            let result = Object.entries(divisionStats)
                .filter(([division, stats]) => (stats.heuresHC + stats.heuresHNC) > 0) // Seulement les divisions avec des heures
                .map(([division, stats]) => {
                    let totalHeures = stats.heuresHC + stats.heuresHNC;
                    let tauxChargeabilite = (stats.heuresHC / totalHeures) * 100;
                    return {
                        label: division,
                        value: tauxChargeabilite
                    };
                })
                .sort((a, b) => b.value - a.value);
            
            // Convertir en format attendu par renderChart
            let chartData = {};
            result.forEach(item => {
                chartData[item.label] = item.value;
            });
            
            return chartData;
        }

        function getRepartitionHCHNC() {
            let totalHeuresHC = 0;
            let totalHeuresHNC = 0;
            
            filteredData.forEach(row => {
                let heures = parseFloat(row['Heures']) || 0;
                
                if (row['Type Heure'] === 'HC') {
                    totalHeuresHC += heures;
                } else {
                    totalHeuresHNC += heures;
                }
            });

            return {
                'Heures Chargeables': totalHeuresHC,
                'Heures Non-Chargeables': totalHeuresHNC
            };
        }

        function getPerformanceByMonth() {
            let monthStats = {};
            
            filteredData.forEach(row => {
                let mois = row['Mois'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                
                if (!monthStats[mois]) {
                    monthStats[mois] = { heuresHC: 0, heuresHNC: 0 };
                }
                
                if (row['Type Heure'] === 'HC') {
                    monthStats[mois].heuresHC += heures;
                } else {
                    monthStats[mois].heuresHNC += heures;
                }
            });

            return Object.entries(monthStats)
                .sort((a, b) => a[0].localeCompare(b[0]))
                .reduce((obj, [mois, stats]) => {
                    let totalHeures = stats.heuresHC + stats.heuresHNC;
                    obj[mois] = totalHeures > 0 ? (stats.heuresHC / totalHeures) * 100 : 0;
                    return obj;
                }, {});
        }

        // ===== ONGLET OPPORTUNIT√âS =====
        // Focus : Pipeline commercial et opportunit√©s - Page autonome
        function renderOpportunitesTab() {
            if (!opportunitesData.length) {
                document.getElementById('tab-opportunites').innerHTML = '<div class="no-data">Aucune donn√©e d\'opportunit√©s disponible</div>';
                return;
            }

            let opportunitesStats = calculateOpportunitesStats();

            let opportunitesHTML = `
                <div class="kpi-cards">
                    <div class="kpi-card">
                        <span class="kpi-icon">üéØ</span>
                        <div class="kpi-label">Total Opportunit√©s</div>
                        <div class="kpi-value">${opportunitesStats.totalOpportunites}</div>
                    </div>
                    <div class="kpi-card">
                        <span class="kpi-icon">üí∞</span>
                        <div class="kpi-label">Valeur Totale</div>
                        <div class="kpi-value">${opportunitesStats.valeurTotale.toLocaleString()} XAF</div>
                    </div>
                    <div class="kpi-card">
                        <span class="kpi-icon">üìä</span>
                        <div class="kpi-label">Taux de Conversion</div>
                        <div class="kpi-value">${opportunitesStats.tauxConversion.toFixed(1)}%</div>
                    </div>
                    <div class="kpi-card">
                        <span class="kpi-icon">üìà</span>
                        <div class="kpi-label">Valeur Moyenne</div>
                        <div class="kpi-value">${opportunitesStats.valeurMoyenne.toLocaleString()} XAF</div>
                    </div>
                    <div class="kpi-card">
                        <span class="kpi-icon">üèÜ</span>
                        <div class="kpi-label">Opportunit√©s Gagn√©es</div>
                        <div class="kpi-value">${opportunitesStats.opportunitesGagnees}</div>
                    </div>
                    <div class="kpi-card">
                        <span class="kpi-icon">‚è≥</span>
                        <div class="kpi-label">En Cours</div>
                        <div class="kpi-value">${opportunitesStats.enCours}</div>
                    </div>
                </div>
                
                <!-- Filtres sp√©cifiques aux opportunit√©s -->
                <div class="filters-section" style="margin: 20px 0; padding: 15px; background: #f8f9fa; border-radius: 8px;">
                    <h3 style="margin-bottom: 15px; color: #333;">Filtres Opportunit√©s</h3>
                    <div class="filters-row">
                        <div class="filter-group">
                            <label for="opportuniteDivisionFilter">Division:</label>
                            <select id="opportuniteDivisionFilter">
                                <option value="">Toutes les divisions</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label for="opportuniteStatutFilter">Statut:</label>
                            <select id="opportuniteStatutFilter">
                                <option value="">Tous les statuts</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label for="opportuniteResponsableFilter">Responsable:</label>
                            <select id="opportuniteResponsableFilter">
                                <option value="">Tous les responsables</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label for="opportuniteSecteurFilter">Secteur:</label>
                            <select id="opportuniteSecteurFilter">
                                <option value="">Tous les secteurs</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label for="opportuniteTypeFilter">Type:</label>
                            <select id="opportuniteTypeFilter">
                                <option value="">Tous les types</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label for="opportuniteInitiativeFilter">Initiative:</label>
                            <select id="opportuniteInitiativeFilter">
                                <option value="">Toutes les initiatives</option>
                            </select>
                        </div>
                    </div>
                </div>
                
                <div class="charts-row">
                    <div class="chart-container">
                        <div class="section-title">Opportunit√©s par Division</div>
                        <canvas id="opportunitesChartDivision"></canvas>
                    </div>
                    <div class="chart-container">
                        <div class="section-title">R√©partition par Statut</div>
                        <canvas id="opportunitesChartStatut"></canvas>
                    </div>
                </div>
                <div class="charts-row">
                    <div class="chart-container">
                        <div class="section-title">Valeur par Secteur</div>
                        <canvas id="opportunitesChartSecteur"></canvas>
                    </div>
                    <div class="chart-container">
                        <div class="section-title">Top Responsables</div>
                        <canvas id="opportunitesChartResponsable"></canvas>
                    </div>
                </div>
                <div class="chart-container" style="margin-top: 20px;">
                    <div class="section-title">Pipeline Commercial</div>
                    <table id="opportunitesTable">
                        <thead>
                            <tr>
                                <th>Client</th>
                                <th>Opportunit√©</th>
                                <th>Division</th>
                                <th>Responsable</th>
                                <th>Valeur</th>
                                <th>Probabilit√©</th>
                                <th>Statut</th>
                                <th>Secteur</th>
                                <th>Type</th>
                                <th>Date Insertion</th>
                                <th>Derni√®re Action</th>
                                <th>Prochaine Action</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${generateOpportunitesTable()}
                        </tbody>
                    </table>
                </div>
            `;

            document.getElementById('tab-opportunites').innerHTML = opportunitesHTML;

            // Initialiser les filtres sp√©cifiques aux opportunit√©s
            setupOpportunitesFilters();
            
            // Appliquer les filtres initiaux
            applyOpportunitesFilters();

            // Rendu des graphiques
            renderChart('opportunitesChartDivision', getOpportunitesByDivision(), 'bar', 'Division', 'Valeur (XAF)');
            renderChart('opportunitesChartStatut', getOpportunitesByStatut(), 'doughnut', 'Statut', 'Nombre');
            renderChart('opportunitesChartSecteur', getOpportunitesBySecteur(), 'bar', 'Secteur', 'Valeur (XAF)');
            renderChart('opportunitesChartResponsable', getOpportunitesByResponsable(), 'bar', 'Responsable', 'Valeur (XAF)');
        }

        // ===== FONCTIONS FACTURATION =====
        function calculateFacturationStats() {
            let totalFactures = facturesData.length;
            let montantFacture = facturesData.reduce((sum, facture) => {
                let montant = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                return sum + montant;
            }, 0);
            let montantEncaisse = facturesData.reduce((sum, facture) => {
                let montant = parseFloat(facture['Montant Encaiss√©']?.replace(/\s/g, '') || '0');
                return sum + montant;
            }, 0);
            let tauxEncaissement = montantFacture > 0 ? (montantEncaisse / montantFacture) * 100 : 0;

            return {
                totalFactures,
                montantFacture,
                montantEncaisse,
                tauxEncaissement
            };
        }

        function getFacturationByDivision() {
            let divisionStats = {};
            facturesData.forEach(facture => {
                let division = facture['Division'] || 'Non d√©fini';
                let montant = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                
                if (!divisionStats[division]) {
                    divisionStats[division] = 0;
                }
                divisionStats[division] += montant;
            });

            return Object.entries(divisionStats)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10)
                .map(([division, montant]) => ({
                    label: division,
                    value: montant
                }));
        }

        function getFacturationByEtat() {
            let etatStats = {};
            facturesData.forEach(facture => {
                let montantFacture = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                let montantEncaisse = parseFloat(facture['Montant Encaiss√©']?.replace(/\s/g, '') || '0');
                let solde = montantFacture - montantEncaisse;
                let etat = solde === 0 ? 'Pay√©' : solde > 0 ? 'En attente' : 'Surpay√©';
                
                if (!etatStats[etat]) {
                    etatStats[etat] = 0;
                }
                etatStats[etat]++;
            });

            return Object.entries(etatStats).map(([etat, count]) => ({
                label: etat,
                value: count
            }));
        }

        function generateFacturationTable() {
            return facturesData.map(facture => {
                let montantFacture = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                let montantEncaisse = parseFloat(facture['Montant Encaiss√©']?.replace(/\s/g, '') || '0');
                let solde = montantFacture - montantEncaisse;
                let etat = solde === 0 ? 'Pay√©' : solde > 0 ? 'En attente' : 'Surpay√©';
                
                return `
                    <tr>
                        <td>${facture['Client'] || ''}</td>
                        <td>${facture['Mission'] || ''}</td>
                        <td>${facture['Division'] || ''}</td>
                        <td>${montantFacture.toLocaleString()} XAF</td>
                        <td>${montantEncaisse.toLocaleString()} XAF</td>
                        <td>${solde.toLocaleString()} XAF</td>
                        <td>${etat}</td>
                    </tr>
                `;
            }).join('');
        }

        // ===== FONCTIONS RENTABILIT√â =====
        function calculateRentabiliteStats() {
            // Calculer les co√ªts √† partir des donn√©es TRS filtr√©es
            let coutTotal = calculateTotalCost();
            
            // Calculer le CA √† partir des factures
            let caTotal = facturesData.reduce((sum, facture) => {
                let montant = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                return sum + montant;
            }, 0);
            
            let margeBrute = caTotal - coutTotal;
            let tauxMarge = caTotal > 0 ? (margeBrute / caTotal) * 100 : 0;
            
            // Nouveaux KPIs
            let roiGlobal = coutTotal > 0 ? (margeBrute / coutTotal) * 100 : 0;
            
            // Calculer le taux de rentabilit√© (missions rentables / total missions)
            let missionStats = {};
            filteredData.forEach(row => {
                let mission = row['Missions'] || 'Non d√©fini';
                if (!missionStats[mission]) {
                    missionStats[mission] = { cout: 0, ca: 0 };
                }
                if (row['Type Heure'] === 'HC') {
                    let heures = parseFloat(row['Heures']) || 0;
                    let taux = gradeToTaux[row['Grade']] || 0;
                    missionStats[mission].cout += heures * taux;
                }
            });
            
            facturesData.forEach(facture => {
                let mission = facture['Mission'] || 'Non d√©fini';
                let montant = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                if (!missionStats[mission]) {
                    missionStats[mission] = { cout: 0, ca: 0 };
                }
                missionStats[mission].ca += montant;
            });
            
            let missionsRentables = Object.values(missionStats).filter(stats => (stats.ca - stats.cout) > 0).length;
            let totalMissions = Object.keys(missionStats).length;
            let tauxRentabilite = totalMissions > 0 ? (missionsRentables / totalMissions) * 100 : 0;
            
            // CA moyen par mission
            let missionsFacturees = facturesData.length;
            let caMoyen = missionsFacturees > 0 ? caTotal / missionsFacturees : 0;

            return {
                caTotal,
                coutTotal,
                margeBrute,
                tauxMarge,
                roiGlobal,
                tauxRentabilite,
                caMoyen
            };
        }

        function getRentabiliteByMission() {
            let missionStats = {};
            
            // Calculer les co√ªts par mission (uniquement heures HC)
            filteredData.forEach(row => {
                let mission = row['Missions'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                let taux = gradeToTaux[row['Grade']] || 0;
                
                if (!missionStats[mission]) {
                    missionStats[mission] = { cout: 0, ca: 0 };
                }
                
                // Ne calculer le co√ªt que pour les heures HC
                if (row['Type Heure'] === 'HC') {
                    let cout = heures * taux;
                    missionStats[mission].cout += cout;
                }
            });
            
            // Ajouter les CA par mission depuis les factures
            facturesData.forEach(facture => {
                let mission = facture['Mission'] || 'Non d√©fini';
                let montant = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                
                if (!missionStats[mission]) {
                    missionStats[mission] = { cout: 0, ca: 0 };
                }
                missionStats[mission].ca += montant;
            });

            return Object.entries(missionStats)
                .map(([mission, stats]) => ({
                    label: mission,
                    value: stats.ca - stats.cout
                }))
                .sort((a, b) => b.value - a.value)
                .slice(0, 10);
        }

        function getRentabiliteByDivision() {
            let divisionStats = {};
            
            // Calculer les co√ªts par division (uniquement heures HC)
            filteredData.forEach(row => {
                let division = row['Division'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                let taux = gradeToTaux[row['Grade']] || 0;
                
                if (!divisionStats[division]) {
                    divisionStats[division] = { cout: 0, ca: 0 };
                }
                
                // Ne calculer le co√ªt que pour les heures HC
                if (row['Type Heure'] === 'HC') {
                    let cout = heures * taux;
                    divisionStats[division].cout += cout;
                }
            });
            
            // Ajouter les CA par division depuis les factures
            facturesData.forEach(facture => {
                let division = facture['Division'] || 'Non d√©fini';
                let montant = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                
                if (!divisionStats[division]) {
                    divisionStats[division] = { cout: 0, ca: 0 };
                }
                divisionStats[division].ca += montant;
            });

            return Object.entries(divisionStats)
                .map(([division, stats]) => ({
                    label: division,
                    value: stats.ca - stats.cout
                }))
                .sort((a, b) => b.value - a.value);
        }

        function getRentabiliteByMonth() {
            let monthStats = {};
            
            // Calculer les marges par mois
            filteredData.forEach(row => {
                let mois = row['Mois'] || 'Non d√©fini';
                let mission = row['Missions'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                let taux = gradeToTaux[row['Grade']] || 0;
                
                if (!monthStats[mois]) {
                    monthStats[mois] = { cout: 0, ca: 0 };
                }
                
                if (row['Type Heure'] === 'HC') {
                    let cout = heures * taux;
                    monthStats[mois].cout += cout;
                }
            });
            
            // Ajouter les CA par mois depuis les factures
            facturesData.forEach(facture => {
                let date = facture['Date'] || '';
                let mois = date.split('/')[1] || 'Non d√©fini'; // Extraire le mois de la date
                let montant = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                
                if (!monthStats[mois]) {
                    monthStats[mois] = { cout: 0, ca: 0 };
                }
                monthStats[mois].ca += montant;
            });
            
            return Object.entries(monthStats)
                .sort((a, b) => a[0].localeCompare(b[0]))
                .reduce((obj, [mois, stats]) => {
                    obj[mois] = stats.ca - stats.cout;
                    return obj;
                }, {});
        }

        function getRentabiliteByMarges() {
            let missionStats = {};
            
            // Calculer les marges par mission
            filteredData.forEach(row => {
                let mission = row['Missions'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                let taux = gradeToTaux[row['Grade']] || 0;
                
                if (!missionStats[mission]) {
                    missionStats[mission] = { cout: 0, ca: 0 };
                }
                
                if (row['Type Heure'] === 'HC') {
                    let cout = heures * taux;
                    missionStats[mission].cout += cout;
                }
            });
            
            facturesData.forEach(facture => {
                let mission = facture['Mission'] || 'Non d√©fini';
                let montant = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                
                if (!missionStats[mission]) {
                    missionStats[mission] = { cout: 0, ca: 0 };
                }
                missionStats[mission].ca += montant;
            });
            
            // Cat√©goriser les marges
            let margeCategories = {
                'D√©ficitaire (< 0)': 0,
                'Faible (0-50k)': 0,
                'Moyenne (50k-200k)': 0,
                '√âlev√©e (200k-500k)': 0,
                'Tr√®s √©lev√©e (> 500k)': 0
            };
            
            Object.values(missionStats).forEach(stats => {
                let marge = stats.ca - stats.cout;
                if (marge < 0) {
                    margeCategories['D√©ficitaire (< 0)']++;
                } else if (marge < 50000) {
                    margeCategories['Faible (0-50k)']++;
                } else if (marge < 200000) {
                    margeCategories['Moyenne (50k-200k)']++;
                } else if (marge < 500000) {
                    margeCategories['√âlev√©e (200k-500k)']++;
                } else {
                    margeCategories['Tr√®s √©lev√©e (> 500k)']++;
                }
            });
            
            return margeCategories;
        }

        function generateRentabiliteTable() {
            let missionStats = {};
            
            // Calculer les co√ªts par mission (uniquement heures HC)
            filteredData.forEach(row => {
                let mission = row['Missions'] || 'Non d√©fini';
                let division = row['Division'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                let taux = gradeToTaux[row['Grade']] || 0;
                
                if (!missionStats[mission]) {
                    missionStats[mission] = { 
                        division: division,
                        cout: 0, 
                        ca: 0,
                        heuresHC: 0
                    };
                }
                
                // Ne calculer le co√ªt que pour les heures HC
                if (row['Type Heure'] === 'HC') {
                    let cout = heures * taux;
                    missionStats[mission].cout += cout;
                    missionStats[mission].heuresHC += heures;
                }
            });
            
            // Ajouter les CA par mission depuis les factures
            facturesData.forEach(facture => {
                let mission = facture['Mission'] || 'Non d√©fini';
                let montant = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                
                if (!missionStats[mission]) {
                    missionStats[mission] = { 
                        division: facture['Division'] || 'Non d√©fini',
                        cout: 0, 
                        ca: 0,
                        heuresHC: 0
                    };
                }
                missionStats[mission].ca += montant;
            });

            return Object.entries(missionStats)
                .map(([mission, stats]) => {
                    let marge = stats.ca - stats.cout;
                    let tauxMarge = stats.ca > 0 ? (marge / stats.ca) * 100 : 0;
                    let roi = stats.cout > 0 ? (marge / stats.cout) * 100 : 0;
                    let coutParHeure = stats.heuresHC > 0 ? stats.cout / stats.heuresHC : 0;
                    let caParHeure = stats.heuresHC > 0 ? stats.ca / stats.heuresHC : 0;
                    let rentabilite = marge > 0 ? 'Rentable' : marge < 0 ? 'D√©ficitaire' : '√âquilibr√©';
                    
                    // Classes CSS pour les alertes
                    let alertClass = '';
                    if (marge < 0 || roi < 20) {
                        alertClass = 'alert-low-rentability';
                    }
                    
                    return `
                        <tr class="${alertClass}">
                            <td>${mission}</td>
                            <td>${stats.division}</td>
                            <td>${stats.heuresHC.toFixed(1)}h</td>
                            <td>${stats.cout.toLocaleString()} XAF</td>
                            <td>${stats.ca.toLocaleString()} XAF</td>
                            <td>${marge.toLocaleString()} XAF</td>
                            <td>${tauxMarge.toFixed(1)}%</td>
                            <td>${roi.toFixed(1)}%</td>
                            <td>${coutParHeure.toFixed(0)} XAF/h</td>
                            <td>${caParHeure.toFixed(0)} XAF/h</td>
                            <td>${rentabilite}</td>
                        </tr>
                    `;
                })
                .sort((a, b) => {
                    // Trier par rentabilit√© d√©croissante
                    let margeA = parseFloat(a.match(/td>([^<]+) XAF<\/td>/)[1].replace(/\s/g, ''));
                    let margeB = parseFloat(b.match(/td>([^<]+) XAF<\/td>/)[1].replace(/\s/g, ''));
                    return margeB - margeA;
                })
                .join('');
        }

        // ===== FONCTIONS PERFORMANCE =====
        function calculatePerformanceStats() {
            let collaborateurStats = {};
            
            filteredData.forEach(row => {
                let nom = row['Nom'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                let grade = row['Grade'] || 'Non d√©fini';
                let division = row['Division'] || 'Non d√©fini';
                let taux = gradeToTaux[grade] || 0;
                
                if (!collaborateurStats[nom]) {
                    collaborateurStats[nom] = {
                        heures: 0,
                        heuresHC: 0,
                        heuresHNC: 0,
                        cout: 0,
                        grade: grade,
                        division: division
                    };
                }
                
                collaborateurStats[nom].heures += heures;
                
                // Ne calculer le co√ªt que pour les heures HC
                if (row['Type Heure'] === 'HC') {
                    let cout = heures * taux;
                    collaborateurStats[nom].cout += cout;
                    collaborateurStats[nom].heuresHC += heures;
                } else {
                    collaborateurStats[nom].heuresHNC += heures;
                }
            });

            let totalCollaborateurs = Object.keys(collaborateurStats).length;
            let totalHeures = Object.values(collaborateurStats).reduce((sum, stats) => sum + stats.heures, 0);
            let heuresMoyennes = totalCollaborateurs > 0 ? totalHeures / totalCollaborateurs : 0;
            
            // Calculer le taux de chargeabilit√© global
            let totalHeuresHC = Object.values(collaborateurStats).reduce((sum, stats) => sum + stats.heuresHC, 0);
            let totalHeuresHNC = Object.values(collaborateurStats).reduce((sum, stats) => sum + stats.heuresHNC, 0);
            let tauxChargeabilite = (totalHeuresHC + totalHeuresHNC) > 0 ? (totalHeuresHC / (totalHeuresHC + totalHeuresHNC)) * 100 : 0;
            
            // Trouver le collaborateur le plus efficace (ratio HNC/HC le plus faible)
            let plusEfficace = Object.entries(collaborateurStats)
                .filter(([nom, stats]) => stats.heuresHC > 0 && (stats.heuresHC + stats.heuresHNC) > 0) // Seulement ceux avec des heures HC et total > 0
                .sort((a, b) => {
                    let ratioA = a[1].heuresHNC / a[1].heuresHC;
                    let ratioB = b[1].heuresHNC / b[1].heuresHC;
                    return ratioA - ratioB; // Plus le ratio est faible, meilleur
                })[0];
            let plusEfficaceName = plusEfficace ? plusEfficace[0] : 'N/A';

            return {
                totalCollaborateurs,
                heuresMoyennes,
                tauxChargeabilite,
                plusEfficace: plusEfficaceName
            };
        }





        function generatePerformanceTable() {
            let collaborateurStats = {};
            
            filteredData.forEach(row => {
                let nom = row['Nom'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                let grade = row['Grade'] || 'Non d√©fini';
                let division = row['Division'] || 'Non d√©fini';
                
                if (!collaborateurStats[nom]) {
                    collaborateurStats[nom] = {
                        heures: 0,
                        heuresHC: 0,
                        heuresHNC: 0,
                        grade: grade,
                        division: division
                    };
                }
                
                collaborateurStats[nom].heures += heures;
                
                if (row['Type Heure'] === 'HC') {
                    collaborateurStats[nom].heuresHC += heures;
                } else {
                    collaborateurStats[nom].heuresHNC += heures;
                }
            });

            // Calculer la productivit√© moyenne pour la comparaison
            let productivites = Object.values(collaborateurStats)
                .filter(stats => stats.heuresHC > 0)
                .map(stats => stats.heuresHNC / stats.heuresHC);
            let productiviteMoyenne = productivites.length > 0 ? 
                productivites.reduce((sum, val) => sum + val, 0) / productivites.length : 0;

            return Object.entries(collaborateurStats)
                .map(([nom, stats]) => {
                    let tauxChargeabilite = (stats.heuresHC + stats.heuresHNC) > 0 ? 
                        (stats.heuresHC / (stats.heuresHC + stats.heuresHNC)) * 100 : 0;
                    let ratioHCHNC = stats.heuresHC > 0 ? stats.heuresHNC / stats.heuresHC : 0;
                    let productiviteRelative = productiviteMoyenne > 0 ? 
                        ((productiviteMoyenne - ratioHCHNC) / productiviteMoyenne) * 100 : 0;
                    
                    // D√©terminer le statut
                    let statut = '';
                    let alertClass = '';
                    if (ratioHCHNC > 1.5) {
                        statut = '‚ö†Ô∏è Sous-performant';
                        alertClass = 'alert-low-performance';
                    } else if (ratioHCHNC < 0.5) {
                        statut = '‚úÖ Excellent';
                        alertClass = 'alert-excellent-performance';
                    } else if (ratioHCHNC < 1) {
                        statut = 'üëç Bon';
                        alertClass = 'alert-good-performance';
                    } else {
                        statut = '‚ö†Ô∏è √Ä am√©liorer';
                        alertClass = 'alert-medium-performance';
                    }
                    
                    return `
                        <tr class="${alertClass}">
                            <td>${nom}</td>
                            <td>${stats.grade}</td>
                            <td>${stats.division}</td>
                            <td>${stats.heures.toFixed(1)}h</td>
                            <td>${stats.heuresHC.toFixed(1)}h</td>
                            <td>${stats.heuresHNC.toFixed(1)}h</td>
                            <td>${tauxChargeabilite.toFixed(1)}%</td>
                            <td>${ratioHCHNC.toFixed(2)}</td>
                            <td>${ratioHCHNC.toFixed(2)}</td>
                            <td>${productiviteRelative.toFixed(1)}%</td>
                            <td>${statut}</td>
                        </tr>
                    `;
                })
                .sort((a, b) => {
                    // Trier par ratio HNC/HC croissant (meilleur en premier)
                    let ratioA = parseFloat(a.match(/td>([^<]+)<\/td>/g)[7].replace(/<\/?td>/g, ''));
                    let ratioB = parseFloat(b.match(/td>([^<]+)<\/td>/g)[7].replace(/<\/?td>/g, ''));
                    return ratioA - ratioB;
                })
                .join('');
        }

        function getTopCollaborateursProductivite() {
            let collaborateurStats = {};
            
            filteredData.forEach(row => {
                let nom = row['Nom'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                
                if (!collaborateurStats[nom]) {
                    collaborateurStats[nom] = { heuresHC: 0, heuresHNC: 0 };
                }
                
                if (row['Type Heure'] === 'HC') {
                    collaborateurStats[nom].heuresHC += heures;
                } else {
                    collaborateurStats[nom].heuresHNC += heures;
                }
            });

            let result = Object.entries(collaborateurStats)
                .filter(([nom, stats]) => stats.heuresHC > 0 && (stats.heuresHC + stats.heuresHNC) > 0) // Seulement ceux avec des heures HC et total > 0
                .map(([nom, stats]) => {
                    let ratio = stats.heuresHNC / stats.heuresHC;
                    return {
                        label: nom.length > 15 ? nom.substring(0, 15) + '...' : nom,
                        value: ratio
                    };
                })
                .sort((a, b) => a.value - b.value) // Plus le ratio est faible, meilleur
                .slice(0, 5);
            
            // Convertir en format attendu par renderChart
            let chartData = {};
            result.forEach(item => {
                chartData[item.label] = item.value;
            });
            
            return chartData;
        }

        function getPerformanceByDivision() {
            let divisionStats = {};
            
            filteredData.forEach(row => {
                let division = row['Division'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                
                if (!divisionStats[division]) {
                    divisionStats[division] = { heuresHC: 0, heuresHNC: 0 };
                }
                
                if (row['Type Heure'] === 'HC') {
                    divisionStats[division].heuresHC += heures;
                } else {
                    divisionStats[division].heuresHNC += heures;
                }
            });

            let result = Object.entries(divisionStats)
                .filter(([division, stats]) => (stats.heuresHC + stats.heuresHNC) > 0) // Seulement les divisions avec des heures
                .map(([division, stats]) => {
                    let totalHeures = stats.heuresHC + stats.heuresHNC;
                    let tauxChargeabilite = (stats.heuresHC / totalHeures) * 100;
                    return {
                        label: division,
                        value: tauxChargeabilite
                    };
                })
                .sort((a, b) => b.value - a.value);
            
            // Convertir en format attendu par renderChart
            let chartData = {};
            result.forEach(item => {
                chartData[item.label] = item.value;
            });
            
            return chartData;
        }

        function getRepartitionHCHNC() {
            let totalHeuresHC = 0;
            let totalHeuresHNC = 0;
            
            filteredData.forEach(row => {
                let heures = parseFloat(row['Heures']) || 0;
                
                if (row['Type Heure'] === 'HC') {
                    totalHeuresHC += heures;
                } else {
                    totalHeuresHNC += heures;
                }
            });

            return {
                'Heures Chargeables': totalHeuresHC,
                'Heures Non-Chargeables': totalHeuresHNC
            };
        }

        function getPerformanceByMonth() {
            let monthStats = {};
            
            filteredData.forEach(row => {
                let mois = row['Mois'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                
                if (!monthStats[mois]) {
                    monthStats[mois] = { heuresHC: 0, heuresHNC: 0 };
                }
                
                if (row['Type Heure'] === 'HC') {
                    monthStats[mois].heuresHC += heures;
                } else {
                    monthStats[mois].heuresHNC += heures;
                }
            });

            return Object.entries(monthStats)
                .sort((a, b) => a[0].localeCompare(b[0]))
                .reduce((obj, [mois, stats]) => {
                    let totalHeures = stats.heuresHC + stats.heuresHNC;
                    obj[mois] = totalHeures > 0 ? (stats.heuresHC / totalHeures) * 100 : 0;
                    return obj;
                }, {});
        }

        // ===== ONGLET OPPORTUNIT√âS =====
        // Focus : Pipeline commercial et opportunit√©s - Page autonome
        function renderOpportunitesTab() {
            if (!opportunitesData.length) {
                document.getElementById('tab-opportunites').innerHTML = '<div class="no-data">Aucune donn√©e d\'opportunit√©s disponible</div>';
                return;
            }

            let opportunitesStats = calculateOpportunitesStats();

            let opportunitesHTML = `
                <div class="kpi-cards">
                    <div class="kpi-card">
                        <span class="kpi-icon">üéØ</span>
                        <div class="kpi-label">Total Opportunit√©s</div>
                        <div class="kpi-value">${opportunitesStats.totalOpportunites}</div>
                    </div>
                    <div class="kpi-card">
                        <span class="kpi-icon">üí∞</span>
                        <div class="kpi-label">Valeur Totale</div>
                        <div class="kpi-value">${opportunitesStats.valeurTotale.toLocaleString()} XAF</div>
                    </div>
                    <div class="kpi-card">
                        <span class="kpi-icon">üìä</span>
                        <div class="kpi-label">Taux de Conversion</div>
                        <div class="kpi-value">${opportunitesStats.tauxConversion.toFixed(1)}%</div>
                    </div>
                    <div class="kpi-card">
                        <span class="kpi-icon">üìà</span>
                        <div class="kpi-label">Valeur Moyenne</div>
                        <div class="kpi-value">${opportunitesStats.valeurMoyenne.toLocaleString()} XAF</div>
                    </div>
                    <div class="kpi-card">
                        <span class="kpi-icon">üèÜ</span>
                        <div class="kpi-label">Opportunit√©s Gagn√©es</div>
                        <div class="kpi-value">${opportunitesStats.opportunitesGagnees}</div>
                    </div>
                    <div class="kpi-card">
                        <span class="kpi-icon">‚è≥</span>
                        <div class="kpi-label">En Cours</div>
                        <div class="kpi-value">${opportunitesStats.enCours}</div>
                    </div>
                </div>
                
                <!-- Filtres sp√©cifiques aux opportunit√©s -->
                <div class="filters-section" style="margin: 20px 0; padding: 15px; background: #f8f9fa; border-radius: 8px;">
                    <h3 style="margin-bottom: 15px; color: #333;">Filtres Opportunit√©s</h3>
                    <div class="filters-row">
                        <div class="filter-group">
                            <label for="opportuniteDivisionFilter">Division:</label>
                            <select id="opportuniteDivisionFilter">
                                <option value="">Toutes les divisions</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label for="opportuniteStatutFilter">Statut:</label>
                            <select id="opportuniteStatutFilter">
                                <option value="">Tous les statuts</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label for="opportuniteResponsableFilter">Responsable:</label>
                            <select id="opportuniteResponsableFilter">
                                <option value="">Tous les responsables</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label for="opportuniteSecteurFilter">Secteur:</label>
                            <select id="opportuniteSecteurFilter">
                                <option value="">Tous les secteurs</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label for="opportuniteTypeFilter">Type:</label>
                            <select id="opportuniteTypeFilter">
                                <option value="">Tous les types</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label for="opportuniteInitiativeFilter">Initiative:</label>
                            <select id="opportuniteInitiativeFilter">
                                <option value="">Toutes les initiatives</option>
                            </select>
                        </div>
                    </div>
                </div>
                
                <div class="charts-row">
                    <div class="chart-container">
                        <div class="section-title">Opportunit√©s par Division</div>
                        <canvas id="opportunitesChartDivision"></canvas>
                    </div>
                    <div class="chart-container">
                        <div class="section-title">R√©partition par Statut</div>
                        <canvas id="opportunitesChartStatut"></canvas>
                    </div>
                </div>
                <div class="charts-row">
                    <div class="chart-container">
                        <div class="section-title">Valeur par Secteur</div>
                        <canvas id="opportunitesChartSecteur"></canvas>
                    </div>
                    <div class="chart-container">
                        <div class="section-title">Top Responsables</div>
                        <canvas id="opportunitesChartResponsable"></canvas>
                    </div>
                </div>
                <div class="chart-container" style="margin-top: 20px;">
                    <div class="section-title">Pipeline Commercial</div>
                    <table id="opportunitesTable">
                        <thead>
                            <tr>
                                <th>Client</th>
                                <th>Opportunit√©</th>
                                <th>Division</th>
                                <th>Responsable</th>
                                <th>Valeur</th>
                                <th>Probabilit√©</th>
                                <th>Statut</th>
                                <th>Secteur</th>
                                <th>Type</th>
                                <th>Date Insertion</th>
                                <th>Derni√®re Action</th>
                                <th>Prochaine Action</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${generateOpportunitesTable()}
                        </tbody>
                    </table>
                </div>
            `;

            document.getElementById('tab-opportunites').innerHTML = opportunitesHTML;

            // Initialiser les filtres sp√©cifiques aux opportunit√©s
            setupOpportunitesFilters();
            
            // Appliquer les filtres initiaux
            applyOpportunitesFilters();

            // Rendu des graphiques
            renderChart('opportunitesChartDivision', getOpportunitesByDivision(), 'bar', 'Division', 'Valeur (XAF)');
            renderChart('opportunitesChartStatut', getOpportunitesByStatut(), 'doughnut', 'Statut', 'Nombre');
            renderChart('opportunitesChartSecteur', getOpportunitesBySecteur(), 'bar', 'Secteur', 'Valeur (XAF)');
            renderChart('opportunitesChartResponsable', getOpportunitesByResponsable(), 'bar', 'Responsable', 'Valeur (XAF)');
        }

        // ===== FONCTIONS FACTURATION =====
        function calculateFacturationStats() {
            let totalFactures = facturesData.length;
            let montantFacture = facturesData.reduce((sum, facture) => {
                let montant = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                return sum + montant;
            }, 0);
            let montantEncaisse = facturesData.reduce((sum, facture) => {
                let montant = parseFloat(facture['Montant Encaiss√©']?.replace(/\s/g, '') || '0');
                return sum + montant;
            }, 0);
            let tauxEncaissement = montantFacture > 0 ? (montantEncaisse / montantFacture) * 100 : 0;

            return {
                totalFactures,
                montantFacture,
                montantEncaisse,
                tauxEncaissement
            };
        }

        function getFacturationByDivision() {
            let divisionStats = {};
            facturesData.forEach(facture => {
                let division = facture['Division'] || 'Non d√©fini';
                let montant = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                
                if (!divisionStats[division]) {
                    divisionStats[division] = 0;
                }
                divisionStats[division] += montant;
            });

            return Object.entries(divisionStats)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10)
                .map(([division, montant]) => ({
                    label: division,
                    value: montant
                }));
        }

        function getFacturationByEtat() {
            let etatStats = {};
            facturesData.forEach(facture => {
                let montantFacture = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                let montantEncaisse = parseFloat(facture['Montant Encaiss√©']?.replace(/\s/g, '') || '0');
                let solde = montantFacture - montantEncaisse;
                let etat = solde === 0 ? 'Pay√©' : solde > 0 ? 'En attente' : 'Surpay√©';
                
                if (!etatStats[etat]) {
                    etatStats[etat] = 0;
                }
                etatStats[etat]++;
            });

            return Object.entries(etatStats).map(([etat, count]) => ({
                label: etat,
                value: count
            }));
        }

        function generateFacturationTable() {
            return facturesData.map(facture => {
                let montantFacture = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                let montantEncaisse = parseFloat(facture['Montant Encaiss√©']?.replace(/\s/g, '') || '0');
                let solde = montantFacture - montantEncaisse;
                let etat = solde === 0 ? 'Pay√©' : solde > 0 ? 'En attente' : 'Surpay√©';
                
                return `
                    <tr>
                        <td>${facture['Client'] || ''}</td>
                        <td>${facture['Mission'] || ''}</td>
                        <td>${facture['Division'] || ''}</td>
                        <td>${montantFacture.toLocaleString()} XAF</td>
                        <td>${montantEncaisse.toLocaleString()} XAF</td>
                        <td>${solde.toLocaleString()} XAF</td>
                        <td>${etat}</td>
                    </tr>
                `;
            }).join('');
        }

        // ===== FONCTIONS RENTABILIT√â =====
        function calculateRentabiliteStats() {
            // Calculer les co√ªts √† partir des donn√©es TRS filtr√©es
            let coutTotal = calculateTotalCost();
            
            // Calculer le CA √† partir des factures
            let caTotal = facturesData.reduce((sum, facture) => {
                let montant = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                return sum + montant;
            }, 0);
            
            let margeBrute = caTotal - coutTotal;
            let tauxMarge = caTotal > 0 ? (margeBrute / caTotal) * 100 : 0;
            
            // Nouveaux KPIs
            let roiGlobal = coutTotal > 0 ? (margeBrute / coutTotal) * 100 : 0;
            
            // Calculer le taux de rentabilit√© (missions rentables / total missions)
            let missionStats = {};
            filteredData.forEach(row => {
                let mission = row['Missions'] || 'Non d√©fini';
                if (!missionStats[mission]) {
                    missionStats[mission] = { cout: 0, ca: 0 };
                }
                if (row['Type Heure'] === 'HC') {
                    let heures = parseFloat(row['Heures']) || 0;
                    let taux = gradeToTaux[row['Grade']] || 0;
                    missionStats[mission].cout += heures * taux;
                }
            });
            
            facturesData.forEach(facture => {
                let mission = facture['Mission'] || 'Non d√©fini';
                let montant = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                if (!missionStats[mission]) {
                    missionStats[mission] = { cout: 0, ca: 0 };
                }
                missionStats[mission].ca += montant;
            });
            
            let missionsRentables = Object.values(missionStats).filter(stats => (stats.ca - stats.cout) > 0).length;
            let totalMissions = Object.keys(missionStats).length;
            let tauxRentabilite = totalMissions > 0 ? (missionsRentables / totalMissions) * 100 : 0;
            
            // CA moyen par mission
            let missionsFacturees = facturesData.length;
            let caMoyen = missionsFacturees > 0 ? caTotal / missionsFacturees : 0;

            return {
                caTotal,
                coutTotal,
                margeBrute,
                tauxMarge,
                roiGlobal,
                tauxRentabilite,
                caMoyen
            };
        }

        function getRentabiliteByMission() {
            let missionStats = {};
            
            // Calculer les co√ªts par mission (uniquement heures HC)
            filteredData.forEach(row => {
                let mission = row['Missions'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                let taux = gradeToTaux[row['Grade']] || 0;
                
                if (!missionStats[mission]) {
                    missionStats[mission] = { cout: 0, ca: 0 };
                }
                
                // Ne calculer le co√ªt que pour les heures HC
                if (row['Type Heure'] === 'HC') {
                    let cout = heures * taux;
                    missionStats[mission].cout += cout;
                }
            });
            
            // Ajouter les CA par mission depuis les factures
            facturesData.forEach(facture => {
                let mission = facture['Mission'] || 'Non d√©fini';
                let montant = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                
                if (!missionStats[mission]) {
                    missionStats[mission] = { cout: 0, ca: 0 };
                }
                missionStats[mission].ca += montant;
            });

            return Object.entries(missionStats)
                .map(([mission, stats]) => ({
                    label: mission,
                    value: stats.ca - stats.cout
                }))
                .sort((a, b) => b.value - a.value)
                .slice(0, 10);
        }

        function getRentabiliteByDivision() {
            let divisionStats = {};
            
            // Calculer les co√ªts par division (uniquement heures HC)
            filteredData.forEach(row => {
                let division = row['Division'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                let taux = gradeToTaux[row['Grade']] || 0;
                
                if (!divisionStats[division]) {
                    divisionStats[division] = { cout: 0, ca: 0 };
                }
                
                // Ne calculer le co√ªt que pour les heures HC
                if (row['Type Heure'] === 'HC') {
                    let cout = heures * taux;
                    divisionStats[division].cout += cout;
                }
            });
            
            // Ajouter les CA par division depuis les factures
            facturesData.forEach(facture => {
                let division = facture['Division'] || 'Non d√©fini';
                let montant = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                
                if (!divisionStats[division]) {
                    divisionStats[division] = { cout: 0, ca: 0 };
                }
                divisionStats[division].ca += montant;
            });

            return Object.entries(divisionStats)
                .map(([division, stats]) => ({
                    label: division,
                    value: stats.ca - stats.cout
                }))
                .sort((a, b) => b.value - a.value);
        }

        function getRentabiliteByMonth() {
            let monthStats = {};
            
            // Calculer les marges par mois
            filteredData.forEach(row => {
                let mois = row['Mois'] || 'Non d√©fini';
                let mission = row['Missions'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                let taux = gradeToTaux[row['Grade']] || 0;
                
                if (!monthStats[mois]) {
                    monthStats[mois] = { cout: 0, ca: 0 };
                }
                
                if (row['Type Heure'] === 'HC') {
                    let cout = heures * taux;
                    monthStats[mois].cout += cout;
                }
            });
            
            // Ajouter les CA par mois depuis les factures
            facturesData.forEach(facture => {
                let date = facture['Date'] || '';
                let mois = date.split('/')[1] || 'Non d√©fini'; // Extraire le mois de la date
                let montant = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                
                if (!monthStats[mois]) {
                    monthStats[mois] = { cout: 0, ca: 0 };
                }
                monthStats[mois].ca += montant;
            });
            
            return Object.entries(monthStats)
                .sort((a, b) => a[0].localeCompare(b[0]))
                .reduce((obj, [mois, stats]) => {
                    obj[mois] = stats.ca - stats.cout;
                    return obj;
                }, {});
        }

        function getRentabiliteByMarges() {
            let missionStats = {};
            
            // Calculer les marges par mission
            filteredData.forEach(row => {
                let mission = row['Missions'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                let taux = gradeToTaux[row['Grade']] || 0;
                
                if (!missionStats[mission]) {
                    missionStats[mission] = { cout: 0, ca: 0 };
                }
                
                if (row['Type Heure'] === 'HC') {
                    let cout = heures * taux;
                    missionStats[mission].cout += cout;
                }
            });
            
            facturesData.forEach(facture => {
                let mission = facture['Mission'] || 'Non d√©fini';
                let montant = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                
                if (!missionStats[mission]) {
                    missionStats[mission] = { cout: 0, ca: 0 };
                }
                missionStats[mission].ca += montant;
            });
            
            // Cat√©goriser les marges
            let margeCategories = {
                'D√©ficitaire (< 0)': 0,
                'Faible (0-50k)': 0,
                'Moyenne (50k-200k)': 0,
                '√âlev√©e (200k-500k)': 0,
                'Tr√®s √©lev√©e (> 500k)': 0
            };
            
            Object.values(missionStats).forEach(stats => {
                let marge = stats.ca - stats.cout;
                if (marge < 0) {
                    margeCategories['D√©ficitaire (< 0)']++;
                } else if (marge < 50000) {
                    margeCategories['Faible (0-50k)']++;
                } else if (marge < 200000) {
                    margeCategories['Moyenne (50k-200k)']++;
                } else if (marge < 500000) {
                    margeCategories['√âlev√©e (200k-500k)']++;
                } else {
                    margeCategories['Tr√®s √©lev√©e (> 500k)']++;
                }
            });
            
            return margeCategories;
        }

        function generateRentabiliteTable() {
            let missionStats = {};
            
            // Calculer les co√ªts par mission (uniquement heures HC)
            filteredData.forEach(row => {
                let mission = row['Missions'] || 'Non d√©fini';
                let division = row['Division'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                let taux = gradeToTaux[row['Grade']] || 0;
                
                if (!missionStats[mission]) {
                    missionStats[mission] = { 
                        division: division,
                        cout: 0, 
                        ca: 0,
                        heuresHC: 0
                    };
                }
                
                // Ne calculer le co√ªt que pour les heures HC
                if (row['Type Heure'] === 'HC') {
                    let cout = heures * taux;
                    missionStats[mission].cout += cout;
                    missionStats[mission].heuresHC += heures;
                }
            });
            
            // Ajouter les CA par mission depuis les factures
            facturesData.forEach(facture => {
                let mission = facture['Mission'] || 'Non d√©fini';
                let montant = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                
                if (!missionStats[mission]) {
                    missionStats[mission] = { 
                        division: facture['Division'] || 'Non d√©fini',
                        cout: 0, 
                        ca: 0,
                        heuresHC: 0
                    };
                }
                missionStats[mission].ca += montant;
            });

            return Object.entries(missionStats)
                .map(([mission, stats]) => {
                    let marge = stats.ca - stats.cout;
                    let tauxMarge = stats.ca > 0 ? (marge / stats.ca) * 100 : 0;
                    let roi = stats.cout > 0 ? (marge / stats.cout) * 100 : 0;
                    let coutParHeure = stats.heuresHC > 0 ? stats.cout / stats.heuresHC : 0;
                    let caParHeure = stats.heuresHC > 0 ? stats.ca / stats.heuresHC : 0;
                    let rentabilite = marge > 0 ? 'Rentable' : marge < 0 ? 'D√©ficitaire' : '√âquilibr√©';
                    
                    // Classes CSS pour les alertes
                    let alertClass = '';
                    if (marge < 0 || roi < 20) {
                        alertClass = 'alert-low-rentability';
                    }
                    
                    return `
                        <tr class="${alertClass}">
                            <td>${mission}</td>
                            <td>${stats.division}</td>
                            <td>${stats.heuresHC.toFixed(1)}h</td>
                            <td>${stats.cout.toLocaleString()} XAF</td>
                            <td>${stats.ca.toLocaleString()} XAF</td>
                            <td>${marge.toLocaleString()} XAF</td>
                            <td>${tauxMarge.toFixed(1)}%</td>
                            <td>${roi.toFixed(1)}%</td>
                            <td>${coutParHeure.toFixed(0)} XAF/h</td>
                            <td>${caParHeure.toFixed(0)} XAF/h</td>
                            <td>${rentabilite}</td>
                        </tr>
                    `;
                })
                .sort((a, b) => {
                    // Trier par rentabilit√© d√©croissante
                    let margeA = parseFloat(a.match(/td>([^<]+) XAF<\/td>/)[1].replace(/\s/g, ''));
                    let margeB = parseFloat(b.match(/td>([^<]+) XAF<\/td>/)[1].replace(/\s/g, ''));
                    return margeB - margeA;
                })
                .join('');
        }

        // ===== FONCTIONS PERFORMANCE =====
        function calculatePerformanceStats() {
            let collaborateurStats = {};
            
            filteredData.forEach(row => {
                let nom = row['Nom'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                let grade = row['Grade'] || 'Non d√©fini';
                let division = row['Division'] || 'Non d√©fini';
                let taux = gradeToTaux[grade] || 0;
                
                if (!collaborateurStats[nom]) {
                    collaborateurStats[nom] = {
                        heures: 0,
                        heuresHC: 0,
                        heuresHNC: 0,
                        cout: 0,
                        grade: grade,
                        division: division
                    };
                }
                
                collaborateurStats[nom].heures += heures;
                
                // Ne calculer le co√ªt que pour les heures HC
                if (row['Type Heure'] === 'HC') {
                    let cout = heures * taux;
                    collaborateurStats[nom].cout += cout;
                    collaborateurStats[nom].heuresHC += heures;
                } else {
                    collaborateurStats[nom].heuresHNC += heures;
                }
            });

            let totalCollaborateurs = Object.keys(collaborateurStats).length;
            let totalHeures = Object.values(collaborateurStats).reduce((sum, stats) => sum + stats.heures, 0);
            let heuresMoyennes = totalCollaborateurs > 0 ? totalHeures / totalCollaborateurs : 0;
            
            // Calculer le taux de chargeabilit√© global
            let totalHeuresHC = Object.values(collaborateurStats).reduce((sum, stats) => sum + stats.heuresHC, 0);
            let totalHeuresHNC = Object.values(collaborateurStats).reduce((sum, stats) => sum + stats.heuresHNC, 0);
            let tauxChargeabilite = (totalHeuresHC + totalHeuresHNC) > 0 ? (totalHeuresHC / (totalHeuresHC + totalHeuresHNC)) * 100 : 0;
            
            // Trouver le collaborateur le plus efficace (ratio HNC/HC le plus faible)
            let plusEfficace = Object.entries(collaborateurStats)
                .filter(([nom, stats]) => stats.heuresHC > 0 && (stats.heuresHC + stats.heuresHNC) > 0) // Seulement ceux avec des heures HC et total > 0
                .sort((a, b) => {
                    let ratioA = a[1].heuresHNC / a[1].heuresHC;
                    let ratioB = b[1].heuresHNC / b[1].heuresHC;
                    return ratioA - ratioB; // Plus le ratio est faible, meilleur
                })[0];
            let plusEfficaceName = plusEfficace ? plusEfficace[0] : 'N/A';

            return {
                totalCollaborateurs,
                heuresMoyennes,
                tauxChargeabilite,
                plusEfficace: plusEfficaceName
            };
        }





        function generatePerformanceTable() {
            let collaborateurStats = {};
            
            filteredData.forEach(row => {
                let nom = row['Nom'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                let grade = row['Grade'] || 'Non d√©fini';
                let division = row['Division'] || 'Non d√©fini';
                
                if (!collaborateurStats[nom]) {
                    collaborateurStats[nom] = {
                        heures: 0,
                        heuresHC: 0,
                        heuresHNC: 0,
                        grade: grade,
                        division: division
                    };
                }
                
                collaborateurStats[nom].heures += heures;
                
                if (row['Type Heure'] === 'HC') {
                    collaborateurStats[nom].heuresHC += heures;
                } else {
                    collaborateurStats[nom].heuresHNC += heures;
                }
            });

            // Calculer la productivit√© moyenne pour la comparaison
            let productivites = Object.values(collaborateurStats)
                .filter(stats => stats.heuresHC > 0)
                .map(stats => stats.heuresHNC / stats.heuresHC);
            let productiviteMoyenne = productivites.length > 0 ? 
                productivites.reduce((sum, val) => sum + val, 0) / productivites.length : 0;

            return Object.entries(collaborateurStats)
                .map(([nom, stats]) => {
                    let tauxChargeabilite = (stats.heuresHC + stats.heuresHNC) > 0 ? 
                        (stats.heuresHC / (stats.heuresHC + stats.heuresHNC)) * 100 : 0;
                    let ratioHCHNC = stats.heuresHC > 0 ? stats.heuresHNC / stats.heuresHC : 0;
                    let productiviteRelative = productiviteMoyenne > 0 ? 
                        ((productiviteMoyenne - ratioHCHNC) / productiviteMoyenne) * 100 : 0;
                    
                    // D√©terminer le statut
                    let statut = '';
                    let alertClass = '';
                    if (ratioHCHNC > 1.5) {
                        statut = '‚ö†Ô∏è Sous-performant';
                        alertClass = 'alert-low-performance';
                    } else if (ratioHCHNC < 0.5) {
                        statut = '‚úÖ Excellent';
                        alertClass = 'alert-excellent-performance';
                    } else if (ratioHCHNC < 1) {
                        statut = 'üëç Bon';
                        alertClass = 'alert-good-performance';
                    } else {
                        statut = '‚ö†Ô∏è √Ä am√©liorer';
                        alertClass = 'alert-medium-performance';
                    }
                    
                    return `
                        <tr class="${alertClass}">
                            <td>${nom}</td>
                            <td>${stats.grade}</td>
                            <td>${stats.division}</td>
                            <td>${stats.heures.toFixed(1)}h</td>
                            <td>${stats.heuresHC.toFixed(1)}h</td>
                            <td>${stats.heuresHNC.toFixed(1)}h</td>
                            <td>${tauxChargeabilite.toFixed(1)}%</td>
                            <td>${ratioHCHNC.toFixed(2)}</td>
                            <td>${ratioHCHNC.toFixed(2)}</td>
                            <td>${productiviteRelative.toFixed(1)}%</td>
                            <td>${statut}</td>
                        </tr>
                    `;
                })
                .sort((a, b) => {
                    // Trier par ratio HNC/HC croissant (meilleur en premier)
                    let ratioA = parseFloat(a.match(/td>([^<]+)<\/td>/g)[7].replace(/<\/?td>/g, ''));
                    let ratioB = parseFloat(b.match(/td>([^<]+)<\/td>/g)[7].replace(/<\/?td>/g, ''));
                    return ratioA - ratioB;
                })
                .join('');
        }

        function getTopCollaborateursProductivite() {
            let collaborateurStats = {};
            
            filteredData.forEach(row => {
                let nom = row['Nom'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                
                if (!collaborateurStats[nom]) {
                    collaborateurStats[nom] = { heuresHC: 0, heuresHNC: 0 };
                }
                
                if (row['Type Heure'] === 'HC') {
                    collaborateurStats[nom].heuresHC += heures;
                } else {
                    collaborateurStats[nom].heuresHNC += heures;
                }
            });

            let result = Object.entries(collaborateurStats)
                .filter(([nom, stats]) => stats.heuresHC > 0 && (stats.heuresHC + stats.heuresHNC) > 0) // Seulement ceux avec des heures HC et total > 0
                .map(([nom, stats]) => {
                    let ratio = stats.heuresHNC / stats.heuresHC;
                    return {
                        label: nom.length > 15 ? nom.substring(0, 15) + '...' : nom,
                        value: ratio
                    };
                })
                .sort((a, b) => a.value - b.value) // Plus le ratio est faible, meilleur
                .slice(0, 5);
            
            // Convertir en format attendu par renderChart
            let chartData = {};
            result.forEach(item => {
                chartData[item.label] = item.value;
            });
            
            return chartData;
        }

        function getPerformanceByDivision() {
            let divisionStats = {};
            
            filteredData.forEach(row => {
                let division = row['Division'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                
                if (!divisionStats[division]) {
                    divisionStats[division] = { heuresHC: 0, heuresHNC: 0 };
                }
                
                if (row['Type Heure'] === 'HC') {
                    divisionStats[division].heuresHC += heures;
                } else {
                    divisionStats[division].heuresHNC += heures;
                }
            });

            let result = Object.entries(divisionStats)
                .filter(([division, stats]) => (stats.heuresHC + stats.heuresHNC) > 0) // Seulement les divisions avec des heures
                .map(([division, stats]) => {
                    let totalHeures = stats.heuresHC + stats.heuresHNC;
                    let tauxChargeabilite = (stats.heuresHC / totalHeures) * 100;
                    return {
                        label: division,
                        value: tauxChargeabilite
                    };
                })
                .sort((a, b) => b.value - a.value);
            
            // Convertir en format attendu par renderChart
            let chartData = {};
            result.forEach(item => {
                chartData[item.label] = item.value;
            });
            
            return chartData;
        }

        function getRepartitionHCHNC() {
            let totalHeuresHC = 0;
            let totalHeuresHNC = 0;
            
            filteredData.forEach(row => {
                let heures = parseFloat(row['Heures']) || 0;
                
                if (row['Type Heure'] === 'HC') {
                    totalHeuresHC += heures;
                } else {
                    totalHeuresHNC += heures;
                }
            });

            return {
                'Heures Chargeables': totalHeuresHC,
                'Heures Non-Chargeables': totalHeuresHNC
            };
        }

        function getPerformanceByMonth() {
            let monthStats = {};
            
            filteredData.forEach(row => {
                let mois = row['Mois'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                
                if (!monthStats[mois]) {
                    monthStats[mois] = { heuresHC: 0, heuresHNC: 0 };
                }
                
                if (row['Type Heure'] === 'HC') {
                    monthStats[mois].heuresHC += heures;
                } else {
                    monthStats[mois].heuresHNC += heures;
                }
            });

            return Object.entries(monthStats)
                .sort((a, b) => a[0].localeCompare(b[0]))
                .reduce((obj, [mois, stats]) => {
                    let totalHeures = stats.heuresHC + stats.heuresHNC;
                    obj[mois] = totalHeures > 0 ? (stats.heuresHC / totalHeures) * 100 : 0;
                    return obj;
                }, {});
        }

        // ===== ONGLET OPPORTUNIT√âS =====
        // Focus : Pipeline commercial et opportunit√©s - Page autonome
        function renderOpportunitesTab() {
            if (!opportunitesData.length) {
                document.getElementById('tab-opportunites').innerHTML = '<div class="no-data">Aucune donn√©e d\'opportunit√©s disponible</div>';
                return;
            }

            let opportunitesStats = calculateOpportunitesStats();

            let opportunitesHTML = `
                <div class="kpi-cards">
                    <div class="kpi-card">
                        <span class="kpi-icon">üéØ</span>
                        <div class="kpi-label">Total Opportunit√©s</div>
                        <div class="kpi-value">${opportunitesStats.totalOpportunites}</div>
                    </div>
                    <div class="kpi-card">
                        <span class="kpi-icon">üí∞</span>
                        <div class="kpi-label">Valeur Totale</div>
                        <div class="kpi-value">${opportunitesStats.valeurTotale.toLocaleString()} XAF</div>
                    </div>
                    <div class="kpi-card">
                        <span class="kpi-icon">üìä</span>
                        <div class="kpi-label">Taux de Conversion</div>
                        <div class="kpi-value">${opportunitesStats.tauxConversion.toFixed(1)}%</div>
                    </div>
                    <div class="kpi-card">
                        <span class="kpi-icon">üìà</span>
                        <div class="kpi-label">Valeur Moyenne</div>
                        <div class="kpi-value">${opportunitesStats.valeurMoyenne.toLocaleString()} XAF</div>
                    </div>
                    <div class="kpi-card">
                        <span class="kpi-icon">üèÜ</span>
                        <div class="kpi-label">Opportunit√©s Gagn√©es</div>
                        <div class="kpi-value">${opportunitesStats.opportunitesGagnees}</div>
                    </div>
                    <div class="kpi-card">
                        <span class="kpi-icon">‚è≥</span>
                        <div class="kpi-label">En Cours</div>
                        <div class="kpi-value">${opportunitesStats.enCours}</div>
                    </div>
                </div>
                
                <!-- Filtres sp√©cifiques aux opportunit√©s -->
                <div class="filters-section" style="margin: 20px 0; padding: 15px; background: #f8f9fa; border-radius: 8px;">
                    <h3 style="margin-bottom: 15px; color: #333;">Filtres Opportunit√©s</h3>
                    <div class="filters-row">
                        <div class="filter-group">
                            <label for="opportuniteDivisionFilter">Division:</label>
                            <select id="opportuniteDivisionFilter">
                                <option value="">Toutes les divisions</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label for="opportuniteStatutFilter">Statut:</label>
                            <select id="opportuniteStatutFilter">
                                <option value="">Tous les statuts</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label for="opportuniteResponsableFilter">Responsable:</label>
                            <select id="opportuniteResponsableFilter">
                                <option value="">Tous les responsables</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label for="opportuniteSecteurFilter">Secteur:</label>
                            <select id="opportuniteSecteurFilter">
                                <option value="">Tous les secteurs</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label for="opportuniteTypeFilter">Type:</label>
                            <select id="opportuniteTypeFilter">
                                <option value="">Tous les types</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label for="opportuniteInitiativeFilter">Initiative:</label>
                            <select id="opportuniteInitiativeFilter">
                                <option value="">Toutes les initiatives</option>
                            </select>
                        </div>
                    </div>
                </div>
                
                <div class="charts-row">
                    <div class="chart-container">
                        <div class="section-title">Opportunit√©s par Division</div>
                        <canvas id="opportunitesChartDivision"></canvas>
                    </div>
                    <div class="chart-container">
                        <div class="section-title">R√©partition par Statut</div>
                        <canvas id="opportunitesChartStatut"></canvas>
                    </div>
                </div>
                <div class="charts-row">
                    <div class="chart-container">
                        <div class="section-title">Valeur par Secteur</div>
                        <canvas id="opportunitesChartSecteur"></canvas>
                    </div>
                    <div class="chart-container">
                        <div class="section-title">Top Responsables</div>
                        <canvas id="opportunitesChartResponsable"></canvas>
                    </div>
                </div>
                <div class="chart-container" style="margin-top: 20px;">
                    <div class="section-title">Pipeline Commercial</div>
                    <table id="opportunitesTable">
                        <thead>
                            <tr>
                                <th>Client</th>
                                <th>Opportunit√©</th>
                                <th>Division</th>
                                <th>Responsable</th>
                                <th>Valeur</th>
                                <th>Probabilit√©</th>
                                <th>Statut</th>
                                <th>Secteur</th>
                                <th>Type</th>
                                <th>Date Insertion</th>
                                <th>Derni√®re Action</th>
                                <th>Prochaine Action</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${generateOpportunitesTable()}
                        </tbody>
                    </table>
                </div>
            `;

            document.getElementById('tab-opportunites').innerHTML = opportunitesHTML;

            // Initialiser les filtres sp√©cifiques aux opportunit√©s
            setupOpportunitesFilters();
            
            // Appliquer les filtres initiaux
            applyOpportunitesFilters();

            // Rendu des graphiques
            renderChart('opportunitesChartDivision', getOpportunitesByDivision(), 'bar', 'Division', 'Valeur (XAF)');
            renderChart('opportunitesChartStatut', getOpportunitesByStatut(), 'doughnut', 'Statut', 'Nombre');
            renderChart('opportunitesChartSecteur', getOpportunitesBySecteur(), 'bar', 'Secteur', 'Valeur (XAF)');
            renderChart('opportunitesChartResponsable', getOpportunitesByResponsable(), 'bar', 'Responsable', 'Valeur (XAF)');
        }

        // ===== FONCTIONS FACTURATION =====
        function calculateFacturationStats() {
            let totalFactures = facturesData.length;
            let montantFacture = facturesData.reduce((sum, facture) => {
                let montant = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                return sum + montant;
            }, 0);
            let montantEncaisse = facturesData.reduce((sum, facture) => {
                let montant = parseFloat(facture['Montant Encaiss√©']?.replace(/\s/g, '') || '0');
                return sum + montant;
            }, 0);
            let tauxEncaissement = montantFacture > 0 ? (montantEncaisse / montantFacture) * 100 : 0;

            return {
                totalFactures,
                montantFacture,
                montantEncaisse,
                tauxEncaissement
            };
        }

        function getFacturationByDivision() {
            let divisionStats = {};
            facturesData.forEach(facture => {
                let division = facture['Division'] || 'Non d√©fini';
                let montant = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                
                if (!divisionStats[division]) {
                    divisionStats[division] = 0;
                }
                divisionStats[division] += montant;
            });

            return Object.entries(divisionStats)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10)
                .map(([division, montant]) => ({
                    label: division,
                    value: montant
                }));
        }

        function getFacturationByEtat() {
            let etatStats = {};
            facturesData.forEach(facture => {
                let montantFacture = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                let montantEncaisse = parseFloat(facture['Montant Encaiss√©']?.replace(/\s/g, '') || '0');
                let solde = montantFacture - montantEncaisse;
                let etat = solde === 0 ? 'Pay√©' : solde > 0 ? 'En attente' : 'Surpay√©';
                
                if (!etatStats[etat]) {
                    etatStats[etat] = 0;
                }
                etatStats[etat]++;
            });

            return Object.entries(etatStats).map(([etat, count]) => ({
                label: etat,
                value: count
            }));
        }

        function generateFacturationTable() {
            return facturesData.map(facture => {
                let montantFacture = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                let montantEncaisse = parseFloat(facture['Montant Encaiss√©']?.replace(/\s/g, '') || '0');
                let solde = montantFacture - montantEncaisse;
                let etat = solde === 0 ? 'Pay√©' : solde > 0 ? 'En attente' : 'Surpay√©';
                
                return `
                    <tr>
                        <td>${facture['Client'] || ''}</td>
                        <td>${facture['Mission'] || ''}</td>
                        <td>${facture['Division'] || ''}</td>
                        <td>${montantFacture.toLocaleString()} XAF</td>
                        <td>${montantEncaisse.toLocaleString()} XAF</td>
                        <td>${solde.toLocaleString()} XAF</td>
                        <td>${etat}</td>
                    </tr>
                `;
            }).join('');
        }

        // ===== FONCTIONS RENTABILIT√â =====
        function calculateRentabiliteStats() {
            // Calculer les co√ªts √† partir des donn√©es TRS filtr√©es
            let coutTotal = calculateTotalCost();
            
            // Calculer le CA √† partir des factures
            let caTotal = facturesData.reduce((sum, facture) => {
                let montant = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                return sum + montant;
            }, 0);
            
            let margeBrute = caTotal - coutTotal;
            let tauxMarge = caTotal > 0 ? (margeBrute / caTotal) * 100 : 0;
            
            // Nouveaux KPIs
            let roiGlobal = coutTotal > 0 ? (margeBrute / coutTotal) * 100 : 0;
            
            // Calculer le taux de rentabilit√© (missions rentables / total missions)
            let missionStats = {};
            filteredData.forEach(row => {
                let mission = row['Missions'] || 'Non d√©fini';
                if (!missionStats[mission]) {
                    missionStats[mission] = { cout: 0, ca: 0 };
                }
                if (row['Type Heure'] === 'HC') {
                    let heures = parseFloat(row['Heures']) || 0;
                    let taux = gradeToTaux[row['Grade']] || 0;
                    missionStats[mission].cout += heures * taux;
                }
            });
            
            facturesData.forEach(facture => {
                let mission = facture['Mission'] || 'Non d√©fini';
                let montant = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                if (!missionStats[mission]) {
                    missionStats[mission] = { cout: 0, ca: 0 };
                }
                missionStats[mission].ca += montant;
            });
            
            let missionsRentables = Object.values(missionStats).filter(stats => (stats.ca - stats.cout) > 0).length;
            let totalMissions = Object.keys(missionStats).length;
            let tauxRentabilite = totalMissions > 0 ? (missionsRentables / totalMissions) * 100 : 0;
            
            // CA moyen par mission
            let missionsFacturees = facturesData.length;
            let caMoyen = missionsFacturees > 0 ? caTotal / missionsFacturees : 0;

            return {
                caTotal,
                coutTotal,
                margeBrute,
                tauxMarge,
                roiGlobal,
                tauxRentabilite,
                caMoyen
            };
        }

        function getRentabiliteByMission() {
            let missionStats = {};
            
            // Calculer les co√ªts par mission (uniquement heures HC)
            filteredData.forEach(row => {
                let mission = row['Missions'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                let taux = gradeToTaux[row['Grade']] || 0;
                
                if (!missionStats[mission]) {
                    missionStats[mission] = { cout: 0, ca: 0 };
                }
                
                // Ne calculer le co√ªt que pour les heures HC
                if (row['Type Heure'] === 'HC') {
                    let cout = heures * taux;
                    missionStats[mission].cout += cout;
                }
            });
            
            // Ajouter les CA par mission depuis les factures
            facturesData.forEach(facture => {
                let mission = facture['Mission'] || 'Non d√©fini';
                let montant = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                
                if (!missionStats[mission]) {
                    missionStats[mission] = { cout: 0, ca: 0 };
                }
                missionStats[mission].ca += montant;
            });

            return Object.entries(missionStats)
                .map(([mission, stats]) => ({
                    label: mission,
                    value: stats.ca - stats.cout
                }))
                .sort((a, b) => b.value - a.value)
                .slice(0, 10);
        }

        function getRentabiliteByDivision() {
            let divisionStats = {};
            
            // Calculer les co√ªts par division (uniquement heures HC)
            filteredData.forEach(row => {
                let division = row['Division'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                let taux = gradeToTaux[row['Grade']] || 0;
                
                if (!divisionStats[division]) {
                    divisionStats[division] = { cout: 0, ca: 0 };
                }
                
                // Ne calculer le co√ªt que pour les heures HC
                if (row['Type Heure'] === 'HC') {
                    let cout = heures * taux;
                    divisionStats[division].cout += cout;
                }
            });
            
            // Ajouter les CA par division depuis les factures
            facturesData.forEach(facture => {
                let division = facture['Division'] || 'Non d√©fini';
                let montant = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                
                if (!divisionStats[division]) {
                    divisionStats[division] = { cout: 0, ca: 0 };
                }
                divisionStats[division].ca += montant;
            });

            return Object.entries(divisionStats)
                .map(([division, stats]) => ({
                    label: division,
                    value: stats.ca - stats.cout
                }))
                .sort((a, b) => b.value - a.value);
        }

        function getRentabiliteByMonth() {
            let monthStats = {};
            
            // Calculer les marges par mois
            filteredData.forEach(row => {
                let mois = row['Mois'] || 'Non d√©fini';
                let mission = row['Missions'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                let taux = gradeToTaux[row['Grade']] || 0;
                
                if (!monthStats[mois]) {
                    monthStats[mois] = { cout: 0, ca: 0 };
                }
                
                if (row['Type Heure'] === 'HC') {
                    let cout = heures * taux;
                    monthStats[mois].cout += cout;
                }
            });
            
            // Ajouter les CA par mois depuis les factures
            facturesData.forEach(facture => {
                let date = facture['Date'] || '';
                let mois = date.split('/')[1] || 'Non d√©fini'; // Extraire le mois de la date
                let montant = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                
                if (!monthStats[mois]) {
                    monthStats[mois] = { cout: 0, ca: 0 };
                }
                monthStats[mois].ca += montant;
            });
            
            return Object.entries(monthStats)
                .sort((a, b) => a[0].localeCompare(b[0]))
                .reduce((obj, [mois, stats]) => {
                    obj[mois] = stats.ca - stats.cout;
                    return obj;
                }, {});
        }

        function getRentabiliteByMarges() {
            let missionStats = {};
            
            // Calculer les marges par mission
            filteredData.forEach(row => {
                let mission = row['Missions'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                let taux = gradeToTaux[row['Grade']] || 0;
                
                if (!missionStats[mission]) {
                    missionStats[mission] = { cout: 0, ca: 0 };
                }
                
                if (row['Type Heure'] === 'HC') {
                    let cout = heures * taux;
                    missionStats[mission].cout += cout;
                }
            });
            
            facturesData.forEach(facture => {
                let mission = facture['Mission'] || 'Non d√©fini';
                let montant = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                
                if (!missionStats[mission]) {
                    missionStats[mission] = { cout: 0, ca: 0 };
                }
                missionStats[mission].ca += montant;
            });
            
            // Cat√©goriser les marges
            let margeCategories = {
                'D√©ficitaire (< 0)': 0,
                'Faible (0-50k)': 0,
                'Moyenne (50k-200k)': 0,
                '√âlev√©e (200k-500k)': 0,
                'Tr√®s √©lev√©e (> 500k)': 0
            };
            
            Object.values(missionStats).forEach(stats => {
                let marge = stats.ca - stats.cout;
                if (marge < 0) {
                    margeCategories['D√©ficitaire (< 0)']++;
                } else if (marge < 50000) {
                    margeCategories['Faible (0-50k)']++;
                } else if (marge < 200000) {
                    margeCategories['Moyenne (50k-200k)']++;
                } else if (marge < 500000) {
                    margeCategories['√âlev√©e (200k-500k)']++;
                } else {
                    margeCategories['Tr√®s √©lev√©e (> 500k)']++;
                }
            });
            
            return margeCategories;
        }

        function generateRentabiliteTable() {
            let missionStats = {};
            
            // Calculer les co√ªts par mission (uniquement heures HC)
            filteredData.forEach(row => {
                let mission = row['Missions'] || 'Non d√©fini';
                let division = row['Division'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                let taux = gradeToTaux[row['Grade']] || 0;
                
                if (!missionStats[mission]) {
                    missionStats[mission] = { 
                        division: division,
                        cout: 0, 
                        ca: 0,
                        heuresHC: 0
                    };
                }
                
                // Ne calculer le co√ªt que pour les heures HC
                if (row['Type Heure'] === 'HC') {
                    let cout = heures * taux;
                    missionStats[mission].cout += cout;
                    missionStats[mission].heuresHC += heures;
                }
            });
            
            // Ajouter les CA par mission depuis les factures
            facturesData.forEach(facture => {
                let mission = facture['Mission'] || 'Non d√©fini';
                let montant = parseFloat(facture['Montant Factur√©']?.replace(/\s/g, '') || '0');
                
                if (!missionStats[mission]) {
                    missionStats[mission] = { 
                        division: facture['Division'] || 'Non d√©fini',
                        cout: 0, 
                        ca: 0,
                        heuresHC: 0
                    };
                }
                missionStats[mission].ca += montant;
            });

            return Object.entries(missionStats)
                .map(([mission, stats]) => {
                    let marge = stats.ca - stats.cout;
                    let tauxMarge = stats.ca > 0 ? (marge / stats.ca) * 100 : 0;
                    let roi = stats.cout > 0 ? (marge / stats.cout) * 100 : 0;
                    let coutParHeure = stats.heuresHC > 0 ? stats.cout / stats.heuresHC : 0;
                    let caParHeure = stats.heuresHC > 0 ? stats.ca / stats.heuresHC : 0;
                    let rentabilite = marge > 0 ? 'Rentable' : marge < 0 ? 'D√©ficitaire' : '√âquilibr√©';
                    
                    // Classes CSS pour les alertes
                    let alertClass = '';
                    if (marge < 0 || roi < 20) {
                        alertClass = 'alert-low-rentability';
                    }
                    
                    return `
                        <tr class="${alertClass}">
                            <td>${mission}</td>
                            <td>${stats.division}</td>
                            <td>${stats.heuresHC.toFixed(1)}h</td>
                            <td>${stats.cout.toLocaleString()} XAF</td>
                            <td>${stats.ca.toLocaleString()} XAF</td>
                            <td>${marge.toLocaleString()} XAF</td>
                            <td>${tauxMarge.toFixed(1)}%</td>
                            <td>${roi.toFixed(1)}%</td>
                            <td>${coutParHeure.toFixed(0)} XAF/h</td>
                            <td>${caParHeure.toFixed(0)} XAF/h</td>
                            <td>${rentabilite}</td>
                        </tr>
                    `;
                })
                .sort((a, b) => {
                    // Trier par rentabilit√© d√©croissante
                    let margeA = parseFloat(a.match(/td>([^<]+) XAF<\/td>/)[1].replace(/\s/g, ''));
                    let margeB = parseFloat(b.match(/td>([^<]+) XAF<\/td>/)[1].replace(/\s/g, ''));
                    return margeB - margeA;
                })
                .join('');
        }

        // ===== FONCTIONS PERFORMANCE =====
        function calculatePerformanceStats() {
            let collaborateurStats = {};
            
            filteredData.forEach(row => {
                let nom = row['Nom'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                let grade = row['Grade'] || 'Non d√©fini';
                let division = row['Division'] || 'Non d√©fini';
                let taux = gradeToTaux[grade] || 0;
                
                if (!collaborateurStats[nom]) {
                    collaborateurStats[nom] = {
                        heures: 0,
                        heuresHC: 0,
                        heuresHNC: 0,
                        cout: 0,
                        grade: grade,
                        division: division
                    };
                }
                
                collaborateurStats[nom].heures += heures;
                
                // Ne calculer le co√ªt que pour les heures HC
                if (row['Type Heure'] === 'HC') {
                    let cout = heures * taux;
                    collaborateurStats[nom].cout += cout;
                    collaborateurStats[nom].heuresHC += heures;
                } else {
                    collaborateurStats[nom].heuresHNC += heures;
                }
            });

            let totalCollaborateurs = Object.keys(collaborateurStats).length;
            let totalHeures = Object.values(collaborateurStats).reduce((sum, stats) => sum + stats.heures, 0);
            let heuresMoyennes = totalCollaborateurs > 0 ? totalHeures / totalCollaborateurs : 0;
            
            // Calculer le taux de chargeabilit√© global
            let totalHeuresHC = Object.values(collaborateurStats).reduce((sum, stats) => sum + stats.heuresHC, 0);
            let totalHeuresHNC = Object.values(collaborateurStats).reduce((sum, stats) => sum + stats.heuresHNC, 0);
            let tauxChargeabilite = (totalHeuresHC + totalHeuresHNC) > 0 ? (totalHeuresHC / (totalHeuresHC + totalHeuresHNC)) * 100 : 0;
            
            // Trouver le collaborateur le plus efficace (ratio HNC/HC le plus faible)
            let plusEfficace = Object.entries(collaborateurStats)
                .filter(([nom, stats]) => stats.heuresHC > 0 && (stats.heuresHC + stats.heuresHNC) > 0) // Seulement ceux avec des heures HC et total > 0
                .sort((a, b) => {
                    let ratioA = a[1].heuresHNC / a[1].heuresHC;
                    let ratioB = b[1].heuresHNC / b[1].heuresHC;
                    return ratioA - ratioB; // Plus le ratio est faible, meilleur
                })[0];
            let plusEfficaceName = plusEfficace ? plusEfficace[0] : 'N/A';

            return {
                totalCollaborateurs,
                heuresMoyennes,
                tauxChargeabilite,
                plusEfficace: plusEfficaceName
            };
        }





        function generatePerformanceTable() {
            let collaborateurStats = {};
            
            filteredData.forEach(row => {
                let nom = row['Nom'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                let grade = row['Grade'] || 'Non d√©fini';
                let division = row['Division'] || 'Non d√©fini';
                
                if (!collaborateurStats[nom]) {
                    collaborateurStats[nom] = {
                        heures: 0,
                        heuresHC: 0,
                        heuresHNC: 0,
                        grade: grade,
                        division: division
                    };
                }
                
                collaborateurStats[nom].heures += heures;
                
                if (row['Type Heure'] === 'HC') {
                    collaborateurStats[nom].heuresHC += heures;
                } else {
                    collaborateurStats[nom].heuresHNC += heures;
                }
            });

            // Calculer la productivit√© moyenne pour la comparaison
            let productivites = Object.values(collaborateurStats)
                .filter(stats => stats.heuresHC > 0)
                .map(stats => stats.heuresHNC / stats.heuresHC);
            let productiviteMoyenne = productivites.length > 0 ? 
                productivites.reduce((sum, val) => sum + val, 0) / productivites.length : 0;

            return Object.entries(collaborateurStats)
                .map(([nom, stats]) => {
                    let tauxChargeabilite = (stats.heuresHC + stats.heuresHNC) > 0 ? 
                        (stats.heuresHC / (stats.heuresHC + stats.heuresHNC)) * 100 : 0;
                    let ratioHCHNC = stats.heuresHC > 0 ? stats.heuresHNC / stats.heuresHC : 0;
                    let productiviteRelative = productiviteMoyenne > 0 ? 
                        ((productiviteMoyenne - ratioHCHNC) / productiviteMoyenne) * 100 : 0;
                    
                    // D√©terminer le statut
                    let statut = '';
                    let alertClass = '';
                    if (ratioHCHNC > 1.5) {
                        statut = '‚ö†Ô∏è Sous-performant';
                        alertClass = 'alert-low-performance';
                    } else if (ratioHCHNC < 0.5) {
                        statut = '‚úÖ Excellent';
                        alertClass = 'alert-excellent-performance';
                    } else if (ratioHCHNC < 1) {
                        statut = 'üëç Bon';
                        alertClass = 'alert-good-performance';
                    } else {
                        statut = '‚ö†Ô∏è √Ä am√©liorer';
                        alertClass = 'alert-medium-performance';
                    }
                    
                    return `
                        <tr class="${alertClass}">
                            <td>${nom}</td>
                            <td>${stats.grade}</td>
                            <td>${stats.division}</td>
                            <td>${stats.heures.toFixed(1)}h</td>
                            <td>${stats.heuresHC.toFixed(1)}h</td>
                            <td>${stats.heuresHNC.toFixed(1)}h</td>
                            <td>${tauxChargeabilite.toFixed(1)}%</td>
                            <td>${ratioHCHNC.toFixed(2)}</td>
                            <td>${ratioHCHNC.toFixed(2)}</td>
                            <td>${productiviteRelative.toFixed(1)}%</td>
                            <td>${statut}</td>
                        </tr>
                    `;
                })
                .sort((a, b) => {
                    // Trier par ratio HNC/HC croissant (meilleur en premier)
                    let ratioA = parseFloat(a.match(/td>([^<]+)<\/td>/g)[7].replace(/<\/?td>/g, ''));
                    let ratioB = parseFloat(b.match(/td>([^<]+)<\/td>/g)[7].replace(/<\/?td>/g, ''));
                    return ratioA - ratioB;
                })
                .join('');
        }

        function getTopCollaborateursProductivite() {
            let collaborateurStats = {};
            
            filteredData.forEach(row => {
                let nom = row['Nom'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                
                if (!collaborateurStats[nom]) {
                    collaborateurStats[nom] = { heuresHC: 0, heuresHNC: 0 };
                }
                
                if (row['Type Heure'] === 'HC') {
                    collaborateurStats[nom].heuresHC += heures;
                } else {
                    collaborateurStats[nom].heuresHNC += heures;
                }
            });

            let result = Object.entries(collaborateurStats)
                .filter(([nom, stats]) => stats.heuresHC > 0 && (stats.heuresHC + stats.heuresHNC) > 0) // Seulement ceux avec des heures HC et total > 0
                .map(([nom, stats]) => {
                    let ratio = stats.heuresHNC / stats.heuresHC;
                    return {
                        label: nom.length > 15 ? nom.substring(0, 15) + '...' : nom,
                        value: ratio
                    };
                })
                .sort((a, b) => a.value - b.value) // Plus le ratio est faible, meilleur
                .slice(0, 5);
            
            // Convertir en format attendu par renderChart
            let chartData = {};
            result.forEach(item => {
                chartData[item.label] = item.value;
            });
            
            return chartData;
        }

        function getPerformanceByDivision() {
            let divisionStats = {};
            
            filteredData.forEach(row => {
                let division = row['Division'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                
                if (!divisionStats[division]) {
                    divisionStats[division] = { heuresHC: 0, heuresHNC: 0 };
                }
                
                if (row['Type Heure'] === 'HC') {
                    divisionStats[division].heuresHC += heures;
                } else {
                    divisionStats[division].heuresHNC += heures;
                }
            });

            let result = Object.entries(divisionStats)
                .filter(([division, stats]) => (stats.heuresHC + stats.heuresHNC) > 0) // Seulement les divisions avec des heures
                .map(([division, stats]) => {
                    let totalHeures = stats.heuresHC + stats.heuresHNC;
                    let tauxChargeabilite = (stats.heuresHC / totalHeures) * 100;
                    return {
                        label: division,
                        value: tauxChargeabilite
                    };
                })
                .sort((a, b) => b.value - a.value);
            
            // Convertir en format attendu par renderChart
            let chartData = {};
            result.forEach(item => {
                chartData[item.label] = item.value;
            });
            
            return chartData;
        }

        function getRepartitionHCHNC() {
            let totalHeuresHC = 0;
            let totalHeuresHNC = 0;
            
            filteredData.forEach(row => {
                let heures = parseFloat(row['Heures']) || 0;
                
                if (row['Type Heure'] === 'HC') {
                    totalHeuresHC += heures;
                } else {
                    totalHeuresHNC += heures;
                }
            });

            return {
                'Heures Chargeables': totalHeuresHC,
                'Heures Non-Chargeables': totalHeuresHNC
            };
        }

        function getPerformanceByMonth() {
            let monthStats = {};
            
            filteredData.forEach(row => {
                let mois = row['Mois'] || 'Non d√©fini';
                let heures = parseFloat(row['Heures']) || 0;
                
                if (!monthStats[mois]) {
                    monthStats[mois] = { heuresHC: 0, heuresHNC: 0 };
                }
                
                if (row['Type Heure'] === 'HC') {
                    monthStats[mois].heuresHC += heures;
                } else {
                    monthStats[mois].heuresHNC += heures;
                }
            });

            return Object.entries(monthStats)
                .sort((a, b) => a[0].localeCompare(b[0]))
                .reduce((obj, [mois, stats]) => {
                    let totalHeures = stats.heuresHC + stats.heuresHNC;
                    obj[mois] = totalHeures > 0 ? (stats.heuresHC / totalHeures) * 100 : 0;
                    return obj;
                }, {});
        }

        // ===== ONGLET OPPORTUNIT√âS =====
        // Focus : Pipeline commercial et opportunit√©s - Page autonome
        function renderOpportunitesTab() {
            if (!opportunitesData.length) {
                document.getElementById('tab-opportunites').innerHTML = '<div class="no-data">Aucune donn√©e d\'opportunit√©s disponible</div>';
                return;
            }

            let opportunitesStats = calculateOpportunitesStats();

            let opportunitesHTML = `
                <div class="kpi-cards">
                    <div class="kpi-card">
                        <span class="kpi-icon">üéØ</span>
                        <div class="kpi-label">Total Opportunit√©s</div>
                        <div class="kpi-value">${opportunitesStats.totalOpportunites}</div>
                    </div>
                    <div class="kpi-card">
                        <span class="kpi-icon">üí∞</span>
                        <div class="kpi-label">Valeur Totale</div>
                        <div class="kpi-value">${opportunitesStats.valeurTotale.toLocaleString()} XAF</div>
                    </div>
                    <div class="kpi-card">
                        <span class="kpi-icon">üìä</span>
                        <div class="kpi-label">Taux de Conversion</div>
                        <div class="kpi-value">${opportunitesStats.tauxConversion.toFixed(1)}%</div>
                    </div>
                    <div class="kpi-card">
                        <span class="kpi-icon">üìà</span>
                        <div class="kpi-label">Valeur Moyenne</div>
                        <div class="kpi-value">${opportunitesStats.valeurMoyenne.toLocaleString()} XAF</div>
                    </div>
                    <div class="kpi-card">
                        <span class="kpi-icon">üèÜ</span>
                        <div class="kpi-label">Opportunit√©s Gagn√©es</div>
                        <div class="kpi-value">${opportunitesStats.opportunitesGagnees}</div>
                    </div>
                    <div class="kpi-card">
                        <span class="kpi-icon">‚è≥</span>
                        <div class="kpi-label">En Cours</div>
                        <div class="kpi-value">${opportunitesStats.enCours}</div>
                    </div>
                </div>
                
                <!-- Filtres sp√©cifiques aux opportunit√©s -->
                <div class="filters-section" style="margin: 20px 0; padding: 15px; background: #f8f9fa; border-radius: 8px;">
                    <h3 style="margin-bottom: 15px; color: #333;">Filtres Opportunit√©s</h3>
                    <div class="filters-row">
                        <div class="filter-group">
                            <label for="opportuniteDivisionFilter">Division:</label>
                            <select id="opportuniteDivisionFilter">
                                <option value="">Toutes les divisions</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label for="opportuniteStatutFilter">Statut:</label>
                            <select id="opportuniteStatutFilter">
                                <option value="">Tous les statuts</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label for="opportuniteResponsableFilter">Responsable:</label>
                            <select id="opportuniteResponsableFilter">
                                <option value="">Tous les responsables</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label for="opportuniteSecteurFilter">Secteur:</label>
                            <select id="opportuniteSecteurFilter">
                                <option value="">Tous les secteurs</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label for="opportuniteTypeFilter">Type:</label>
                            <select id="opportuniteTypeFilter">
                                <option value="">Tous les types</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label for="opportuniteInitiativeFilter">Initiative:</label>
                            <select id="opportuniteInitiativeFilter">
                                <option value="">Toutes les initiatives</option>
                            </select>
                       