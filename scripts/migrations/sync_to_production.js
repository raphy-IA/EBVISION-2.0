/**
 * Production Data Sync Script
 * 
 * This script connects to the PRODUCTION database and executes
 * the SQL migration files generated by export_for_production.js
 * 
 * Configuration:
 * - Create a .env.production file with production DB credentials
 * - Or set PROD_DB_* environment variables before running
 * 
 * Usage: node scripts/migrations/sync_to_production.js
 */

const { Pool } = require('pg');
const fs = require('fs');
const path = require('path');
const readline = require('readline');

// Config from .env.production or environment variables
let config;

try {
    // Try to load .env.production
    const envPath = path.resolve(__dirname, '../../.env.production');
    if (fs.existsSync(envPath)) {
        const envContent = fs.readFileSync(envPath, 'utf-8');
        const envVars = {};
        envContent.split('\n').forEach(line => {
            const [key, ...valueParts] = line.split('=');
            if (key && valueParts.length > 0) {
                envVars[key.trim()] = valueParts.join('=').trim().replace(/^["']|["']$/g, '');
            }
        });
        config = {
            host: envVars.PROD_DB_HOST || envVars.DB_HOST,
            port: parseInt(envVars.PROD_DB_PORT || envVars.DB_PORT || '5432'),
            database: envVars.PROD_DB_NAME || envVars.DB_NAME,
            user: envVars.PROD_DB_USER || envVars.DB_USER,
            password: envVars.PROD_DB_PASSWORD || envVars.DB_PASSWORD,
            ssl: envVars.PROD_DB_SSL === 'true' ? { rejectUnauthorized: false } : false
        };
        console.log('‚úÖ Loaded config from .env.production');
    } else {
        // Use environment variables
        config = {
            host: process.env.PROD_DB_HOST,
            port: parseInt(process.env.PROD_DB_PORT || '5432'),
            database: process.env.PROD_DB_NAME,
            user: process.env.PROD_DB_USER,
            password: process.env.PROD_DB_PASSWORD,
            ssl: process.env.PROD_DB_SSL === 'true' ? { rejectUnauthorized: false } : false
        };
    }
} catch (e) {
    console.error('Error loading config:', e.message);
}

const SQL_DIR = path.resolve(__dirname, '../../exports_sql');

const SQL_FILES = [
    '01_clients.sql',
    '02_missions.sql',
    '03_mission_tasks.sql',
    '04_equipes_mission.sql',
    '05_internal_activities.sql',
    '06_bu_internal_activities.sql',
    '07_time_sheets.sql',
    '08_time_entries.sql'
];

const VERIFY_QUERIES = {
    '01_clients.sql': 'SELECT COUNT(*) as count FROM clients',
    '02_missions.sql': 'SELECT COUNT(*) as count FROM missions',
    '03_mission_tasks.sql': 'SELECT COUNT(*) as count FROM mission_tasks',
    '04_equipes_mission.sql': 'SELECT COUNT(*) as count FROM equipes_mission',
    '05_internal_activities.sql': 'SELECT COUNT(*) as count FROM internal_activities',
    '06_bu_internal_activities.sql': 'SELECT COUNT(*) as count FROM bu_internal_activities',
    '07_time_sheets.sql': 'SELECT COUNT(*) as count FROM time_sheets',
    '08_time_entries.sql': 'SELECT COUNT(*) as count FROM time_entries'
};

async function prompt(question) {
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });
    return new Promise(resolve => {
        rl.question(question, answer => {
            rl.close();
            resolve(answer);
        });
    });
}

async function syncToProduction() {
    console.log('üöÄ Production Data Sync\n');
    console.log('='.repeat(50));

    // Validate config
    if (!config.host || !config.database || !config.user) {
        console.log('\n‚ö†Ô∏è  Production database config not found!');
        console.log('Please create .env.production with:');
        console.log('  PROD_DB_HOST=your-production-host');
        console.log('  PROD_DB_PORT=5432');
        console.log('  PROD_DB_NAME=your-database');
        console.log('  PROD_DB_USER=your-user');
        console.log('  PROD_DB_PASSWORD=your-password');
        console.log('  PROD_DB_SSL=true (if needed)');
        process.exit(1);
    }

    console.log('\nüìå Target Database:');
    console.log(`   Host: ${config.host}`);
    console.log(`   Port: ${config.port}`);
    console.log(`   Database: ${config.database}`);
    console.log(`   User: ${config.user}`);
    console.log(`   SSL: ${config.ssl ? 'Yes' : 'No'}`);

    // Confirmation
    const confirm = await prompt('\n‚ö†Ô∏è  This will MODIFY PRODUCTION DATA. Continue? (yes/no): ');
    if (confirm.toLowerCase() !== 'yes') {
        console.log('Aborted.');
        process.exit(0);
    }

    // Connect to production
    console.log('\nüîó Connecting to production database...');
    const pool = new Pool(config);

    let client;
    try {
        client = await pool.connect();
        console.log('‚úÖ Connected successfully!');

        // Check which files exist
        const availableFiles = SQL_FILES.filter(f => fs.existsSync(path.join(SQL_DIR, f)));
        console.log(`\nüìÅ Found ${availableFiles.length} SQL files to execute.\n`);

        // Execute each file
        for (const file of availableFiles) {
            console.log(`\nüìÑ Processing: ${file}`);
            console.log('-'.repeat(40));

            const filePath = path.join(SQL_DIR, file);
            let sqlContent = fs.readFileSync(filePath, 'utf-8');

            // Skip DELETE statement for time_entries if user wants merge
            if (file === '08_time_entries.sql') {
                const skipDelete = await prompt('   Delete existing time_entries before insert? (yes/no): ');
                if (skipDelete.toLowerCase() !== 'yes') {
                    sqlContent = sqlContent.replace(/DELETE FROM time_entries;/g, '-- SKIPPED: DELETE FROM time_entries;');
                    console.log('   ‚ÑπÔ∏è  Skipping DELETE, will merge data.');
                }
            }

            // Split into individual statements (simple split on semicolon + newline)
            const statements = sqlContent
                .split(/;\s*\n/)
                .map(s => s.trim())
                .filter(s => s.length > 0 && !s.startsWith('--'));

            console.log(`   Executing ${statements.length} statements...`);

            let successCount = 0;
            let errorCount = 0;

            for (const stmt of statements) {
                try {
                    await client.query(stmt);
                    successCount++;
                } catch (e) {
                    // Ignore ON CONFLICT DO NOTHING errors
                    if (!e.message.includes('duplicate key')) {
                        console.error(`   ‚ùå Error: ${e.message.substring(0, 100)}`);
                        errorCount++;
                    }
                }
            }

            console.log(`   ‚úÖ Success: ${successCount}, ‚ùå Errors: ${errorCount}`);

            // Verify count
            if (VERIFY_QUERIES[file]) {
                const verifyResult = await client.query(VERIFY_QUERIES[file]);
                console.log(`   üìä Table count after sync: ${verifyResult.rows[0].count}`);
            }
        }

        console.log('\n' + '='.repeat(50));
        console.log('‚úÖ Production Sync Complete!');

    } catch (e) {
        console.error('\n‚ùå Error:', e.message);
        if (e.message.includes('ENOTFOUND') || e.message.includes('ETIMEDOUT')) {
            console.log('   Could not reach the production server.');
            console.log('   Check your network/VPN connection.');
        }
    } finally {
        if (client) client.release();
        await pool.end();
        process.exit(0);
    }
}

syncToProduction();
